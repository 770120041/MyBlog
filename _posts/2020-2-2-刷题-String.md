---
layout: post
title:  Python String
categories: Interview
---

## 58. Length of Last Word
```py
class Solution(object):
    def lengthOfLastWord(self, s):
        """
        :type s: str
        :rtype: int
        """
        start = -1
        res = 0
        for i in range(len(s)-1,-1,-1):
            if s[i] != ' ':
                if start > 0:
                    res = max(res,start-i+1) 
                else:
                    start = i
                    res = max(res,1)
            else:
                if res > 0:
                    break
        return res
```
## 387. First Unique Character in a String
```py
class Solution(object):
    def firstUniqChar(self, s):
        d = {}
        for c in s:
            if c not in d:
                d[c] = 1
            else:
                d[c] += 1
        for i in range(len(s)):
            if d[s[i]] == 1:
                return i
        return -1
```

## 383. Ransom Note
```py
class Solution(object):
    def canConstruct(self, ransomNote, magazine):
        d = {}
        for c in magazine:
            if c not in d:
                d[c] = 1
            else:
                d[c] += 1
        for c in ransomNote:
            if c not in d or d[c] <= 0:
                return False
            else:
                d[c] -= 1
        return True
```

## 151. Reverse Words in a String
```
class Solution:
    def reverseWords(self, s: str) -> str:
        if not s: return ""
        words = s.split()
        res = ""
        for i in range(len(words)-1,-1,-1):
            if res:
                res += " "
            res+= words[i]
        return res
```

## 186	Reverse Words in a String II
For in-place, rever the whole string, then reverse each word

## 345. Reverse Vowels of a String
```py
class Solution:
    def reverseVowels(self, s: str) -> str:
        sl = list(s)
        l,r = 0,len(s)-1
        vowels = "aeiouAEIOU"
        while l < r:
            while l < r and sl[l] not in vowels:
                l+=1
            while r > l and sl[r] not in vowels:
                r-=1
            sl[l],sl[r] = sl[r],sl[l]
            l,r = l+1, r-1
        return "".join(sl)
```


## 560. Subarray Sum Equals K
Using HashMap, O(N)
```
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        pre = 0
        d = {0:1}
        cnt = 0
        for i in range(len(nums)):
            pre = pre+nums[i]
            if pre-k in d:
                cnt += d[pre-k]
            if pre not in d:
                d[pre]=1
            else:
                d[pre]+= 1
        return cnt
```


## 205	Isomorphic Strings
注意是双射
```py
class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        s2t,t2s = {},{}
        for i in range(len(s)):
            if (s[i] in s2t and s2t[s[i]] != t[i]) or (t[i] in t2s and t2s[t[i]] != s[i]):
                return False
            s2t[s[i]]=t[i]; t2s[t[i]] = s[i]
        return True
        
```

## 293	Flip Game
```py
class Solution:
    """
    @param s: the given string
    @return: all the possible states of the string after one valid move
    """
    def generatePossibleNextMoves(self, s):
        # write your code here
        res = 0
        for i in range(1,len(s)):
            if s[i-1:i+1] == "++":
                res += 1
        return res
```

## 294 Flip Game II
```
class Solution:
    """
    @param s: the given string
    @return: if the starting player can guarantee a win
    """
    def canWin(self, s):
        return self.helper(s)
    def helper(self,s):
        for i in range(len(s)):
            if i+1<len(s) and s[i:i+2] == "++" and not self.canWin(s[:i]+"--"+s[i+2])
                return True
        return False
```

## 290 Word Pattern
```py
class Solution:
    def wordPattern(self, pattern: str, str: str) -> bool:
        words = str.split()
        p2w, w2p = {},{}
        if len(words) != len(pattern):
            return False
        for i in range(len(pattern)):
            if (pattern[i] in p2w and p2w[pattern[i]] != words[i]) or (words[i] in w2p and w2p[words[i]] != pattern[i]):    return False
            p2w[pattern[i]] = words[i]
            w2p[words[i]] = pattern[i]
        return True
```

## Word Pattern II
```py
class Solution:
    """
    @param pattern: a string,denote pattern string
    @param str: a string, denote matching string
    @return: a boolean
    """
    def wordPatternMatch(self, p, s):
        def dfs(p, s, p_s, s_p):
            if len(p) == 0:
                return len(s) == 0
            for l in range(len(s)):
                s_to_match = s[0:l + 1]
                p_to_match = p[0]
                if p_to_match not in p_s and s_to_match not in s_p:
                    p_s[p_to_match], s_p[s_to_match] = s_to_match, p_to_match
                    if dfs(p[1:], s[l+1:], p_s, s_p):
                        return True
                    del p_s[p_to_match]
                    del s_p[s_to_match]
                elif p_s.get(p_to_match, None) == s_to_match and s_p.get(s_to_match, None) == p_to_match and dfs(p[1:], s[l+1:], p_s, s_p):
                    return True
                else:
                    continue
            return False
        return dfs(p, s, {}, {})
```

## 242. Valid Anagram
```py
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        d = {}
        if len(s) != len(t): return False
        for c in s:
            if c not in d: d[c]=1
            else: d[c]+=1
        for c in t:
            if c not in d or d[c] <= 0: return False
            d[c] -= 1
        return True
``` 

## 49. Group Anagrams
```py
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        d = {}
        res = {}
        idx = [0]*len(strs)
        for i in range(len(strs)):
            sl = list(strs[i])
            sl.sort()
            s = "".join(sl)
            if s not in d:
                d[s] = len(d)
            idx[i] = d[s]
            if idx[i] in res:
                res[idx[i]] += [strs[i]]
            else:
                res[idx[i]] = [strs[i]] 
        result = []
        for value in res.values():
            result += [value]
        return result
```

## 249 	Group Shifted Strings
For each number, record the diff between characters, if 1 char,record no diff, otherwise record diff for each postion - the first char, then save that tuple as a key
```py
class Solution:
    """
    @param strings: a string array
    @return: return a list of string array
    """
    def groupStrings(self, strings):
        # write your code here
        d = {}
        e = []
        for s in strings:
            diff = []
            for i in range(1,len(s)):
                diff.append((ord(s[i])-ord(s[0]))%26)
            if len(diff) == 0:
                e.append(s)
            else:
                if tuple(diff) in d:
                    d[tuple(diff)].append(s)
                else:
                    d[tuple(diff)] = [s]
        # print(d)
        res = []
        res += [e]
        for s in d.values():
            res += [s]
        return res
```

## 87. Scramble String
Brute force but with recursion
```py
class Solution:
    def isScramble(self, s1: str, s2: str) -> bool:
        n,m = len(s1),len(s2)
        if n != m or sorted(s1) != sorted(s2): return False
        if s1 == s2: return True
        f = self.isScramble
        for i in range(1,n):
            if (f(s1[:i],s2[:i]) and f(s1[i:],s2[i:])) or (f(s1[:i],s2[-i:]) and f(s1[i:],s2[:-i])):
                return True
        return False
```

## 179. Largest Number
```
class Solution(object):
    def largestNumber(self, nums):
        if not any(nums): return "0"
        return "".join(sorted(map(str, nums), cmp=lambda n1, n2: -1 if n1+n2>n2+n1 else (1 if n1+n2<n2+n1 else 0)))
        
```

## 38.Count and say
```py
class Solution(object):
    def countAndSay(self, n):
        """
        :type n: int
        :rtype: str
        """
        # count repeated same nums
        res = "1"
        if n == 1: return res
        while n>1:
            curChar,tmp="",""
            cnt = 0
            for i in range(len(res)):
                if i > 0:
                    if res[i] != res[i-1]:
                        tmp += str(cnt)+curChar
                        curChar = res[i]
                        cnt = 1
                    else:
                        cnt += 1
                else:
                    cnt,curChar = 1,res[0]
            tmp += str(cnt)+curChar
            res = tmp
            n -= 1
        return res     
```

## 168. Excel Sheet Column Title
```py
class Solution(object):
    def convertToTitle(self, n):
        capitals = [chr(x) for x in range(ord('A'),ord('Z')+1)]
        res = ""
        while n:
            front = capitals[(n-1)%26]
            res =  front + res
            n = (n-1) // 26
        return res
        
```

## 171. Excel Sheet Column Number
```py
class Solution(object):
    def titleToNumber(self, s):
        res = 0
        for i in range(len(s)):
            res = res*26 + ord(s[i])-ord('A')+1
        return res
```

## 358. Rearrange String k Distance Apart
大根堆来实现排序后的插入和删除

First: init counter O(N) {c:5}
把counter 建立堆 O(N)
pop 最多的，添加到末尾， 注意这时候不能把{c:4} 加回到堆里面，应该在k次操作以后再加回去
如果最后堆里面小于k个，不能，否则可以



## edit distance
https://www.cnblogs.com/grandyang/p/4344107.html

## one edit distance
https://www.cnblogs.com/grandyang/p/5184698.html
 
## Remove Duplicate Letters
