---
layout: post
title:  Python Array
categories: Interview
---
## 1353. Maximum Number of Events That Can Be Attended
```java
class Solution {
        public int maxEvents(int[][] events) {
        Arrays.sort(events, (a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]);
        int count = 0;
        boolean[] attended = new boolean[100001];
        
        for (int[] event : events) 
            for (int i = event[0]; i <= event[1]; i++) 
                if (attended[i] == false) {
                    attended[i] = true;
                    count++;
                    break;
                }

        
        return count;
    }
}
```

## 27	Remove Element
```py
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        idx = 0
        for i in range(len(nums)):
            if nums[i] != val:
                nums[idx] = nums[i]
                idx+=1
        return idx
```

## 26. Remove Duplicates from Sorted Array
```py
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        idx = 0
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i-1]: continue
            nums[idx] = nums[i]
            idx += 1
        return idx
```

## 80. Remove Duplicates from Sorted Array II
Can't do `nums[i] == nums[i-2]`, because postions before i may be modified, the index is not reliable
```py
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        idx = 0
        for i in range(len(nums)):
            if i+2 < len(nums) and nums[i] == nums[i+2]: 
                continue
            nums[idx] = nums[i]
            idx += 1
        return idx
```

## 645. Find the Celebrity
```py
class Solution:
    # @param {int} n a party with n people
    # @return {int} the celebrity's label or -1
    def findCelebrity(self, n):
        # flag means if i is celebrity
        flag = [True for i in range(n)]
        for i in range(n):
            for j in range(n):
                if i == j: continue
                ret =  Celebrity.knows(i,j)
                if ret == True:
                    flag[i] = False
                if ret == False:
                    flag[j] = False
        for i in range(n):
            if flag[i]: return i
        return -1
```

## Rotate Array
根据热心网友 waruzhi 的留言，这道题其实还有种类似翻转字符的方法，思路是先把前 n-k 个数字翻转一下，再把后k个数字翻转一下，最后再把整个数组翻转一下：
```py
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        # 1 2 3 4 5 6 7   k  = 3
        # 5 6 7 1 2 3 4
        # reverse first n-k, last k and reverse the whole thing
        if not nums or k%(len(nums))==0: return 0
        def reverse(nums,l,r):
            while l < r:
                nums[l],nums[r] = nums[r],nums[l]
                l+=1
                r-=1
        k = k % len(nums)
        midPoint = len(nums)-k-1
        reverse(nums,0,midPoint)
        reverse(nums,midPoint+1,len(nums)-1)
        reverse(nums,0,len(nums)-1)
```

## 41. First Missing Positive
注意是first missing postive，所以对于0...N-1，一定会有一个数miss. And negative number and 0 are useless
becasue O(n) time and no extra space, think of modify origin array

#### O(N) space
用O(N)space 的bool array即可
 
#### O(1) space
https://www.youtube.com/watch?v=8DqewGsVNkI
```py
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        INF = len(nums)+1
        n = len(nums)
        if not n: return 1
        for i in range(n):
            if nums[i] <=0 or nums[i] > n : nums[i] = INF
        for i in range(n):
            print(nums)
            v = abs(nums[i])
            if v == INF: continue
            if nums[v-1] > 0: nums[v-1] = -nums[v-1]
            
        for i in range(n):
            if nums[i] > 0: return i+1
        return INF
```

## 299. Bulls and Cows
```py
class Solution:
    def getHint(self, secret, guess):
        bulls = sum(map(operator.eq, secret, guess))
        both = sum(min(secret.count(x), guess.count(x)) for x in set(guess))
        return '%dA%dB' % (bulls, both - bulls)
```

## 134. Gas Station
```py
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        #O(N^2) simulate?
        n = len(gas)
        # n start positions
        for start in range(0,n):
            # move m times
            cur_gas = gas[start]
            cur_idx = start
            cnt = 0
            while cnt < n:                
                # print("Start at %d,cur_idx=%d,cur_gas=%d,next_gas=%d"%(start,cur_idx,cur_gas,cur_gas-cost[cur_idx]))
                if cur_gas < cost[cur_idx]:
                    break
                cur_gas -= cost[cur_idx]
                next_idx = (cur_idx+1)%n
                cur_idx = next_idx
                cur_gas += gas[cur_idx]
                cnt += 1
            if cnt == n:
                return start
        return -1
```

## 118. Pascal's Triangle
```py
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        res = []
        if numRows == 0: return res
        res = [[1]]        
        for i in range(1,numRows):
            cur_row = [1]
            for j in range(1,len(res[-1])):
                cur_row.append(res[-1][j]+res[-1][j-1])
            cur_row.append(1)
            res += [cur_row]
        return res
```

## 119. Pascal's Triangle II
```py
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        if rowIndex == 0: return [1]
        pre = [[1]]
        for i in range(rowIndex):
            cur_row = [1]
            for j in range(1,len(pre)):
                cur_row.append(pre[j]+pre[j-1])
            cur_row.append(1)
            pre = cur_row
        return pre
```

## 169. Majority Element
#### Hash map: very simple
#### Voteing algorithm
```py
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        cnt=0
        cur=-1
        first = True
        for num in nums:
            if first:
                first = False
            else:
                if cur == num:
                    cnt += 1
                else:
                    cnt -= 1
            if cnt == 0:
                cnt = 1
                cur = num
        return cur
```

## 229. Majority Element II
要求O(1)空间，投票
```py
class Solution:
    def majorityElement(self, nums: List[int]) -> List[int]:
        INF = 99999999999
        a,b,cnt1,cnt2=INF,INF,0,0
        for num in nums:
            if num == a: cnt1+=1
            elif num == b: cnt2+=1
            elif cnt1 == 0: 
                a = num
                cnt1 = 1
            elif cnt2 == 0: 
                b = num
                cnt2 = 1
            else:
                cnt1 -=1
                cnt2 -=1
        cnt1,cnt2 = 0,0
        for num in nums:
            if num == a: cnt1 += 1
            elif num == b: cnt2 += 1
        res = []
        if cnt1 > len(nums)//3: res.append(a)
        if cnt2 > len(nums)//3: res.append(b)
        return res
```

## 274. H-Index
```py
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        citations.sort()
        n = len(citations)
        for i in range(n):
            h = n-i
            if citations[i] >= h:
                return h
        return 0
```
## 275. H-Index II
```py
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        if n == 0: return 0
        # find the position where nums[i] >= n-i
        # if nums[i] < n-i, increase i
        # else: decrease i
        l,r = 0,n-1
        while l+1 < r:
            mid = (l+r)//2
            if citations[mid] < n-mid:
                l = mid
            else:
                r = mid
        if citations[l]>=n-l: return n-l
        elif citations[r]>=n-r: return n-r
        return 0
```