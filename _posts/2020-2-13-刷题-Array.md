---
layout: post
title:  Python Array
categories: Interview
---
## 1353. Maximum Number of Events That Can Be Attended
```java
class Solution {
        public int maxEvents(int[][] events) {
        Arrays.sort(events, (a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]);
        int count = 0;
        boolean[] attended = new boolean[100001];
        
        for (int[] event : events) 
            for (int i = event[0]; i <= event[1]; i++) 
                if (attended[i] == false) {
                    attended[i] = true;
                    count++;
                    break;
                }

        
        return count;
    }
}
```

## 27	Remove Element
```py
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        idx = 0
        for i in range(len(nums)):
            if nums[i] != val:
                nums[idx] = nums[i]
                idx+=1
        return idx
```

## 26. Remove Duplicates from Sorted Array
```py
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        idx = 0
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i-1]: continue
            nums[idx] = nums[i]
            idx += 1
        return idx
```

## 80. Remove Duplicates from Sorted Array II
Can't do `nums[i] == nums[i-2]`, because postions before i may be modified, the index is not reliable
```py
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        idx = 0
        for i in range(len(nums)):
            if i+2 < len(nums) and nums[i] == nums[i+2]: 
                continue
            nums[idx] = nums[i]
            idx += 1
        return idx
```

## 645. Find the Celebrity
```py
class Solution:
    # @param {int} n a party with n people
    # @return {int} the celebrity's label or -1
    def findCelebrity(self, n):
        # flag means if i is celebrity
        flag = [True for i in range(n)]
        for i in range(n):
            for j in range(n):
                if i == j: continue
                ret =  Celebrity.knows(i,j)
                if ret == True:
                    flag[i] = False
                if ret == False:
                    flag[j] = False
        for i in range(n):
            if flag[i]: return i
        return -1
```

## Rotate Array
根据热心网友 waruzhi 的留言，这道题其实还有种类似翻转字符的方法，思路是先把前 n-k 个数字翻转一下，再把后k个数字翻转一下，最后再把整个数组翻转一下：
```py
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        # 1 2 3 4 5 6 7   k  = 3
        # 5 6 7 1 2 3 4
        # reverse first n-k, last k and reverse the whole thing
        if not nums or k%(len(nums))==0: return 0
        def reverse(nums,l,r):
            while l < r:
                nums[l],nums[r] = nums[r],nums[l]
                l+=1
                r-=1
        k = k % len(nums)
        midPoint = len(nums)-k-1
        reverse(nums,0,midPoint)
        reverse(nums,midPoint+1,len(nums)-1)
        reverse(nums,0,len(nums)-1)
```

## 41. First Missing Positive  ****
注意是first missing postive，所以对于0...N-1，一定会有一个数miss. And negative number and 0 are useless
becasue O(n) time and no extra space, think of modify origin array

#### O(N) space
用O(N)space 的bool array即可
 
#### O(1) space
https://www.youtube.com/watch?v=8DqewGsVNkI
```py
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        INF = len(nums)+1
        n = len(nums)
        if not n: return 1
        for i in range(n):
            if nums[i] <=0 or nums[i] > n : nums[i] = INF
        for i in range(n):
            print(nums)
            v = abs(nums[i])
            if v == INF: continue
            if nums[v-1] > 0: nums[v-1] = -nums[v-1]
            
        for i in range(n):
            if nums[i] > 0: return i+1
        return INF
```

## 299. Bulls and Cows
```py
class Solution:
    def getHint(self, secret, guess):
        bulls = sum(map(operator.eq, secret, guess))
        both = sum(min(secret.count(x), guess.count(x)) for x in set(guess))
        return '%dA%dB' % (bulls, both - bulls)
```

## 134. Gas Station
```py
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        #O(N^2) simulate?
        n = len(gas)
        # n start positions
        for start in range(0,n):
            # move m times
            cur_gas = gas[start]
            cur_idx = start
            cnt = 0
            while cnt < n:                
                # print("Start at %d,cur_idx=%d,cur_gas=%d,next_gas=%d"%(start,cur_idx,cur_gas,cur_gas-cost[cur_idx]))
                if cur_gas < cost[cur_idx]:
                    break
                cur_gas -= cost[cur_idx]
                next_idx = (cur_idx+1)%n
                cur_idx = next_idx
                cur_gas += gas[cur_idx]
                cnt += 1
            if cnt == n:
                return start
        return -1
```

## 118. Pascal's Triangle
```py
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        res = []
        if numRows == 0: return res
        res = [[1]]        
        for i in range(1,numRows):
            cur_row = [1]
            for j in range(1,len(res[-1])):
                cur_row.append(res[-1][j]+res[-1][j-1])
            cur_row.append(1)
            res += [cur_row]
        return res
```

## 119. Pascal's Triangle II
```py
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        if rowIndex == 0: return [1]
        pre = [[1]]
        for i in range(rowIndex):
            cur_row = [1]
            for j in range(1,len(pre)):
                cur_row.append(pre[j]+pre[j-1])
            cur_row.append(1)
            pre = cur_row
        return pre
```

## 169. Majority Element
#### Hash map: very simple
#### Voteing algorithm
```py
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        cnt=0
        cur=-1
        first = True
        for num in nums:
            if first:
                first = False
            else:
                if cur == num:
                    cnt += 1
                else:
                    cnt -= 1
            if cnt == 0:
                cnt = 1
                cur = num
        return cur
```

## 229. Majority Element II ****
要求O(1)空间，投票
```py
class Solution:
    def majorityElement(self, nums: List[int]) -> List[int]:
        INF = 99999999999
        a,b,cnt1,cnt2=INF,INF,0,0
        for num in nums:
            if num == a: cnt1+=1
            elif num == b: cnt2+=1
            elif cnt1 == 0: 
                a = num
                cnt1 = 1
            elif cnt2 == 0: 
                b = num
                cnt2 = 1
            else:
                cnt1 -=1
                cnt2 -=1
        cnt1,cnt2 = 0,0
        for num in nums:
            if num == a: cnt1 += 1
            elif num == b: cnt2 += 1
        res = []
        if cnt1 > len(nums)//3: res.append(a)
        if cnt2 > len(nums)//3: res.append(b)
        return res
```

## 274. H-Index
```py
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        citations.sort()
        n = len(citations)
        for i in range(n):
            h = n-i
            if citations[i] >= h:
                return h
        return 0
```
## 275. H-Index II
```py
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        if n == 0: return 0
        # find the position where nums[i] >= n-i
        # if nums[i] < n-i, increase i
        # else: decrease i
        l,r = 0,n-1
        while l+1 < r:
            mid = (l+r)//2
            if citations[mid] < n-mid:
                l = mid
            else:
                r = mid
        if citations[l]>=n-l: return n-l
        elif citations[r]>=n-r: return n-r
        return 0
```

## 1376. Time Needed to Inform All Employees ****

Complexity
Space: O(n).
Time: O(n).

```py
class Solution(object):
    def numOfMinutes(self, n, headID, manager, informTime):
        # reorder as adj list
        # DFS from head, reach the furthest node
        def dfs(nodeID,informTime):
            print(nodeID)
            time = 0
            for child in children[nodeID]:
                time = max(time,dfs(child,informTime))
            return time+informTime[nodeID]
        
        children = [[] for i in range(n)]
        for i in range(n):
            if manager[i] != -1:
                children[manager[i]].append(i)
        return dfs(headID,informTime)
        return 0
```

## 55. Jump Game ****
#### O(N^2)
```py
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        if n == 0: return False
        dp = [False for i in range(n+1)]
        dp[1] = True
        for i in range(n):
            if dp[i+1]:
                for j in range(1,nums[i]+1):
                    if i+1+j <=n:
                        dp[i+1+j] = True
        return dp[n]
```
#### Reduct to O(N)
```py
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        if n == 0: return False
        max_reach = 1
        for i in range(n):
            if i+1 <= max_reach:
                max_reach = max(max_reach,min(n,i+1+nums[i]))
        return True if max_reach == n else False
```
## 45. Jump Game II ****
O(N^2) TLE
用BFS的思路理解的。就像在一个图中寻找最短路径。一个数就是一个node，它的邻居就是它能reach到的那些点。最后写出来的代码跟greedy差不多。
```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int res = 0, n = nums.size(), i = 0, max_reach = 0;
        while (max_reach < n - 1) {
            ++res;
            int pre = max_reach;
            for (; i <= pre; ++i) {
                max_reach = max(max_reach, i + nums[i]);
            }
            if (pre == max_reach) return -1; // May not need this
        }
        return res;
    }
};
```


```py
class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0: return 0
        max_reach = 0
        i=0
        res = 0
        while max_reach <n-1:
            res += 1
            pre = max_reach
            while i <= pre:
                max_reach = max(max_reach,nums[i]+i)
                i+=1
            if max_reach == pre: return -1
        return res
```
## 1306. Jump Game III
```py
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        if arr[start] == 0: return True
        def dfs(pos,arr,visited=set()):
            if arr[pos] == 0: return True
            l,r = pos+arr[pos],pos-arr[pos]
            if l>=0 and l <len(arr) and l not in visited:
                visited.add(l)
                if dfs(l,arr,visited): return True
                visited.remove(l)
            if r>=0 and r <len(arr) and  r not in visited:
                visited.add(r)
                if dfs(r,arr,visited): return True
                visited.remove(r)
            return False
            
        if dfs(start,arr): return True
        return False
```

## 149. Best Time to Buy and Sell Stock
```py
class Solution:
    def maxProfit(self, prices):
        if not prices: return 0
        low = prices[0]
        res = 0
        for i in range(1,len(prices)):
            if prices[i] > low:
                res = max(res,prices[i]-low)
            else:
                low = prices[i]
        return res
```

## 150. Best Time to Buy and Sell Stock II
这道跟之前那道Best Time to Buy and Sell Stock 买卖股票的最佳时间很类似，但都比较容易解答。这道题由于可以无限次买入和卖出。我们都知道炒股想挣钱当然是低价买入高价抛出，那么这里我们只需要从第二天开始，如果当前价格比之前价格高，则把差值加入利润中，因为我们可以昨天买入，今日卖出，若明日价更高的话，还可以今日买入，明日再抛出。以此类推，遍历完整个数组后即可求得最大利润。代码如下：
```py
class Solution:
    def maxProfit(self, prices):
        n = len(prices)
        res = 0
        for i in range(n-1):
            if prices[i+1] > prices[i]:
                res += prices[i+1]-prices[i]
        return res
```
```py
class Solution:
    def maxProfit(self, prices):
        n = len(prices)
        if n < 2: return 0
        hi,lo=-1,-1
        res = 0
        for price in prices:
            if lo == -1 or (hi == -1 and lo > price):
                lo = price
            elif hi == -1 or price > hi:
                hi = price
            elif price < hi:
                res += hi-lo
                lo = price
                hi = -1
            # print(lo,hi,res)
        if hi > lo:
            res += hi-lo
        return res       
```
## 151. Best Time to Buy and Sell Stock III
```py
class Solution:
    """
    @param prices: Given an integer array
    @return: Maximum profit
    """
    def maxProfit(self, prices):
        n = len(prices)
        dp_l = [0 for i in range(n)]
        dp_r = [0 for i in range(n)]
        lo_l = 9999999999
        hi_r = -lo_l
        for i in range(0,n):
            r_idx = n-1-i
            if i != 0:
                dp_l[i] = dp_l[i-1]
                dp_r[r_idx] = dp_r[r_idx+1]
            if prices[i] < lo_l:
               lo_l = prices[i]
            if prices[r_idx] > hi_r:
               hi_r = prices[r_idx]
            if prices[i] > lo_l:
               dp_l[i] = max(prices[i]-lo_l,dp_l[i])
            if prices[r_idx] < hi_r:
               dp_r[r_idx] = max(hi_r-prices[r_idx],dp_r[r_idx])
        res = 0
        for i in range(n):
            if i != n-1:
                res = max(dp_l[i]+dp_r[i+1],res)
            else:
                res = max(dp_l[i],res)
        return res
```

## 393. Best Time to Buy and Sell Stock IV
https://www.youtube.com/watch?v=oDhu5uGq_ic
```py
class Solution:
    def maxProfit(self, K, prices):
        if K == 0 or prices == []:
            return 0

        days = len(prices)
        num_transactions = K + 1  # 0th transaction up to and including kth transaction is considered.
    
        T = [[0 for _ in range(days)] for _ in range(num_transactions)]
    
        for transaction in range(1, num_transactions):
            max_diff = - prices[0]
            for day in range(1, days):
                T[transaction][day] = max(T[transaction][day - 1],  # No transaction
                                          prices[day] + max_diff)  # price on that day with max diff
                max_diff = max(max_diff,
                               T[transaction - 1][day] - prices[day])  # update max_diff
    
        return T[-1][-1]

```

In Lintcode, there is a case when K is larger than days, so we can use the method in 
Best Time to Buy and Sell Stock II, which will be O(N)


## 309	Best Time to Buy and Sell Stock with Cooldown
https://www.youtube.com/watch?v=oL6mRyTn56M
buy,sold或者cool在第i天的最大值

price的index因为数组的原因向左调整了1
1. `buy[i] = max(buy[i-1], cool[i-1]-prices[i-1]) 第i天持有股票的最大值是i-1天的持有的最大值或者在第i天买入的最大值`
2. `sold[i] = buy[i-1]+prices[i-1] 第i天卖出的最大值是i-1天还持有股票的最大值加上i天卖出的最大值`
3.`cool[i] = max(cool[i-1],sold[i-1]) 第i天不操作的最大值是前一天不操作的最大值加上前一天卖出的最大值`
4. 最后的结果是`max(sold[i],cool[i])是因为要让结果最大，最后的时候应该不持有任何股票，而buy的状态是持有股票的`
```py
class Solution:
    """
    @param prices: a list of integers
    @return: return a integer
    """
    def maxProfit(self, prices):
        n = len(prices)
        buy = [0 for i in range(n+1)]
        sold = [0 for i in range(n+1)]
        cool = [0 for i in range(n+1)]
        buy[0]=-99999999
        for i in range(1,n+1):
            buy[i] = max(buy[i-1], cool[i-1]-prices[i-1])
            sold[i] = buy[i-1]+prices[i-1]
            cool[i] = max(cool[i-1],sold[i-1])
        return max(cool[n],sold[n])
```


## Trapping Rain Water
#### Brute Force O(N^2)
```py
class Solution:
    def maxArea(self, height: List[int]) -> int:
        n = len(height)
        l,r = 0,n-1
        res = 0
        while l < r:
            res = max(res,(r-l)*min(height[r],height[l]))
            # print(l,r,res)
            if height[l] < height[r]: l+=1
            else: r-=1
        return res
```

#### DP
https://leetcode.com/problems/trapping-rain-water/solution/
using the idea from brute force, we can try to find the max_l and max_r first, then for each postion
```py
class Solution:
    def trap(self, height: List[int]) -> int:
        # find the max from 0 to i
        n = len(height)
        max_l = [height[0] for i in range(n)]
        max_r = [height[n-1] for i in range(n)]
        for i in range(1,n):
            max_l[i] = max(max_l[i-1],height[i])
            max_r[n-1-i] = max(max_r[n-i],height[n-1-i])
        res = 0
        for i in range(1,n-1):
            res += min(max_l[i],max_r[i])-height[i]
        return res
```

## Trapping Rain Water II

#### 直接二维DP
直接计算一个矩形的最小值是错误的，因为最后桶的形状可能不是矩形，如果按照矩形算会偏大
```py
class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -> int:
        # 2D trapping rain water
        # 2D dp
        m = len(heightMap)
        if not m: return 0
        n = len(heightMap[0])
        if not n: return 0
        dp_l_r = [[0 for i in range(n)] for j in range(m)]
        dp_r_l = [[0 for i in range(n)] for j in range(m)]
        dp_u_d = [[0 for i in range(n)] for j in range(m)]
        dp_d_u = [[0 for i in range(n)] for j in range(m)]
        for i in range(m):
            for j in range(n):
                if j == 0:
                    dp_l_r[i][j] = heightMap[i][j]
                    dp_r_l[i][n-1-j] = heightMap[i][n-1-j]
                else:
                    dp_l_r[i][j] = max(dp_l_r[i][j-1],heightMap[i][j]) 
                    dp_r_l[i][n-1-j] = max(dp_r_l[i][n-j],heightMap[i][n-1-j])
        for j in range(n):
            for i in range(m):
                if i == 0:
                    dp_u_d[i][j] = heightMap[i][j]
                    dp_d_u[m-1-i][j] = heightMap[m-1-i][j]
                else:
                    dp_u_d[i][j] = max(dp_u_d[i-1][j],heightMap[i][j])
                    dp_d_u[m-1-i][j] = max(dp_d_u[m-i][j],heightMap[m-1-i][j])
        res = 0
        for i in range(1,m-1):
            for j in range(1,n-1):
                if min(dp_l_r[i][j], dp_r_l[i][j], dp_u_d[i][j], dp_d_u[i][j]) > heightMap[i][j] or (i == 1 and j == 4):
                    print((i,j),dp_l_r[i][j], dp_r_l[i][j], dp_u_d[i][j], dp_d_u[i][j],heightMap[i][j])
                res += min(dp_l_r[i][j], dp_r_l[i][j], dp_u_d[i][j], dp_d_u[i][j])-heightMap[i][j]
        return res
```
#### BFS+priority_queue
