---
layout: post
title:  Python Array
categories: Interview
---
## 1353. Maximum Number of Events That Can Be Attended
```java
class Solution {
        public int maxEvents(int[][] events) {
        Arrays.sort(events, (a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]);
        int count = 0;
        boolean[] attended = new boolean[100001];
        
        for (int[] event : events) 
            for (int i = event[0]; i <= event[1]; i++) 
                if (attended[i] == false) {
                    attended[i] = true;
                    count++;
                    break;
                }

        
        return count;
    }
}
```

## 27	Remove Element
```py
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        idx = 0
        for i in range(len(nums)):
            if nums[i] != val:
                nums[idx] = nums[i]
                idx+=1
        return idx
```

## 26. Remove Duplicates from Sorted Array
```py
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        idx = 0
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i-1]: continue
            nums[idx] = nums[i]
            idx += 1
        return idx
```

## 80. Remove Duplicates from Sorted Array II
Can't do `nums[i] == nums[i-2]`, because postions before i may be modified, the index is not reliable
```py
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        idx = 0
        for i in range(len(nums)):
            if i+2 < len(nums) and nums[i] == nums[i+2]: 
                continue
            nums[idx] = nums[i]
            idx += 1
        return idx
```

## 645. Find the Celebrity
```py
class Solution:
    # @param {int} n a party with n people
    # @return {int} the celebrity's label or -1
    def findCelebrity(self, n):
        # flag means if i is celebrity
        flag = [True for i in range(n)]
        for i in range(n):
            for j in range(n):
                if i == j: continue
                ret =  Celebrity.knows(i,j)
                if ret == True:
                    flag[i] = False
                if ret == False:
                    flag[j] = False
        for i in range(n):
            if flag[i]: return i
        return -1
```

## Rotate Array
根据热心网友 waruzhi 的留言，这道题其实还有种类似翻转字符的方法，思路是先把前 n-k 个数字翻转一下，再把后k个数字翻转一下，最后再把整个数组翻转一下：
```py
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        # 1 2 3 4 5 6 7   k  = 3
        # 5 6 7 1 2 3 4
        # reverse first n-k, last k and reverse the whole thing
        if not nums or k%(len(nums))==0: return 0
        def reverse(nums,l,r):
            while l < r:
                nums[l],nums[r] = nums[r],nums[l]
                l+=1
                r-=1
        k = k % len(nums)
        midPoint = len(nums)-k-1
        reverse(nums,0,midPoint)
        reverse(nums,midPoint+1,len(nums)-1)
        reverse(nums,0,len(nums)-1)
```

## 41. First Missing Positive
注意是first missing postive，所以对于0...N-1，一定会有一个数miss. And negative number and 0 are useless
becasue O(n) time and no extra space, think of modify origin array

#### O(N) space
用O(N)space 的bool array即可
 
#### O(1) space
https://www.youtube.com/watch?v=8DqewGsVNkI
```py
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        INF = len(nums)+1
        n = len(nums)
        if not n: return 1
        for i in range(n):
            if nums[i] <=0 or nums[i] > n : nums[i] = INF
        for i in range(n):
            print(nums)
            v = abs(nums[i])
            if v == INF: continue
            if nums[v-1] > 0: nums[v-1] = -nums[v-1]
            
        for i in range(n):
            if nums[i] > 0: return i+1
        return INF
```

## 299. Bulls and Cows
```py
class Solution:
    def getHint(self, secret, guess):
        bulls = sum(map(operator.eq, secret, guess))
        both = sum(min(secret.count(x), guess.count(x)) for x in set(guess))
        return '%dA%dB' % (bulls, both - bulls)
```