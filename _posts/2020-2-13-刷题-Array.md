---
layout: post
title:  Python Array
categories: Interview
---
## 1353. Maximum Number of Events That Can Be Attended
```java
class Solution {
        public int maxEvents(int[][] events) {
        Arrays.sort(events, (a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]);
        int count = 0;
        boolean[] attended = new boolean[100001];
        
        for (int[] event : events) 
            for (int i = event[0]; i <= event[1]; i++) 
                if (attended[i] == false) {
                    attended[i] = true;
                    count++;
                    break;
                }

        
        return count;
    }
}
```

## 27	Remove Element
```py
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        idx = 0
        for i in range(len(nums)):
            if nums[i] != val:
                nums[idx] = nums[i]
                idx+=1
        return idx
```

## 26. Remove Duplicates from Sorted Array
```py
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        idx = 0
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i-1]: continue
            nums[idx] = nums[i]
            idx += 1
        return idx
```

## 80. Remove Duplicates from Sorted Array II
Can't do `nums[i] == nums[i-2]`, because postions before i may be modified, the index is not reliable
```py
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        idx = 0
        for i in range(len(nums)):
            if i+2 < len(nums) and nums[i] == nums[i+2]: 
                continue
            nums[idx] = nums[i]
            idx += 1
        return idx
```

## 645. Find the Celebrity
```py
class Solution:
    # @param {int} n a party with n people
    # @return {int} the celebrity's label or -1
    def findCelebrity(self, n):
        # flag means if i is celebrity
        flag = [True for i in range(n)]
        for i in range(n):
            for j in range(n):
                if i == j: continue
                ret =  Celebrity.knows(i,j)
                if ret == True:
                    flag[i] = False
                if ret == False:
                    flag[j] = False
        for i in range(n):
            if flag[i]: return i
        return -1
```

## Rotate Array
根据热心网友 waruzhi 的留言，这道题其实还有种类似翻转字符的方法，思路是先把前 n-k 个数字翻转一下，再把后k个数字翻转一下，最后再把整个数组翻转一下：
```py
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        # 1 2 3 4 5 6 7   k  = 3
        # 5 6 7 1 2 3 4
        # reverse first n-k, last k and reverse the whole thing
        if not nums or k%(len(nums))==0: return 0
        def reverse(nums,l,r):
            while l < r:
                nums[l],nums[r] = nums[r],nums[l]
                l+=1
                r-=1
        k = k % len(nums)
        midPoint = len(nums)-k-1
        reverse(nums,0,midPoint)
        reverse(nums,midPoint+1,len(nums)-1)
        reverse(nums,0,len(nums)-1)
```

## 41. First Missing Positive  ****
注意是first missing postive，所以对于0...N-1，一定会有一个数miss. And negative number and 0 are useless
becasue O(n) time and no extra space, think of modify origin array

#### O(N) space
用O(N)space 的bool array即可
 
#### O(1) space
https://www.youtube.com/watch?v=8DqewGsVNkI
```py
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        INF = len(nums)+1
        n = len(nums)
        if not n: return 1
        for i in range(n):
            if nums[i] <=0 or nums[i] > n : nums[i] = INF
        for i in range(n):
            print(nums)
            v = abs(nums[i])
            if v == INF: continue
            if nums[v-1] > 0: nums[v-1] = -nums[v-1]
            
        for i in range(n):
            if nums[i] > 0: return i+1
        return INF
```

## 299. Bulls and Cows
```py
class Solution:
    def getHint(self, secret, guess):
        bulls = sum(map(operator.eq, secret, guess))
        both = sum(min(secret.count(x), guess.count(x)) for x in set(guess))
        return '%dA%dB' % (bulls, both - bulls)
```

## 134. Gas Station
```py
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        #O(N^2) simulate?
        n = len(gas)
        # n start positions
        for start in range(0,n):
            # move m times
            cur_gas = gas[start]
            cur_idx = start
            cnt = 0
            while cnt < n:                
                # print("Start at %d,cur_idx=%d,cur_gas=%d,next_gas=%d"%(start,cur_idx,cur_gas,cur_gas-cost[cur_idx]))
                if cur_gas < cost[cur_idx]:
                    break
                cur_gas -= cost[cur_idx]
                next_idx = (cur_idx+1)%n
                cur_idx = next_idx
                cur_gas += gas[cur_idx]
                cnt += 1
            if cnt == n:
                return start
        return -1
```

## 118. Pascal's Triangle
```py
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        res = []
        if numRows == 0: return res
        res = [[1]]        
        for i in range(1,numRows):
            cur_row = [1]
            for j in range(1,len(res[-1])):
                cur_row.append(res[-1][j]+res[-1][j-1])
            cur_row.append(1)
            res += [cur_row]
        return res
```

## 119. Pascal's Triangle II
```py
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        if rowIndex == 0: return [1]
        pre = [[1]]
        for i in range(rowIndex):
            cur_row = [1]
            for j in range(1,len(pre)):
                cur_row.append(pre[j]+pre[j-1])
            cur_row.append(1)
            pre = cur_row
        return pre
```

## 169. Majority Element
#### Hash map: very simple
#### Voteing algorithm
```py
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        cnt=0
        cur=-1
        first = True
        for num in nums:
            if first:
                first = False
            else:
                if cur == num:
                    cnt += 1
                else:
                    cnt -= 1
            if cnt == 0:
                cnt = 1
                cur = num
        return cur
```

## 229. Majority Element II ****
要求O(1)空间，投票
```py
class Solution:
    def majorityElement(self, nums: List[int]) -> List[int]:
        INF = 99999999999
        a,b,cnt1,cnt2=INF,INF,0,0
        for num in nums:
            if num == a: cnt1+=1
            elif num == b: cnt2+=1
            elif cnt1 == 0: 
                a = num
                cnt1 = 1
            elif cnt2 == 0: 
                b = num
                cnt2 = 1
            else:
                cnt1 -=1
                cnt2 -=1
        cnt1,cnt2 = 0,0
        for num in nums:
            if num == a: cnt1 += 1
            elif num == b: cnt2 += 1
        res = []
        if cnt1 > len(nums)//3: res.append(a)
        if cnt2 > len(nums)//3: res.append(b)
        return res
```

## 274. H-Index
```py
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        citations.sort()
        n = len(citations)
        for i in range(n):
            h = n-i
            if citations[i] >= h:
                return h
        return 0
```
## 275. H-Index II
```py
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        if n == 0: return 0
        # find the position where nums[i] >= n-i
        # if nums[i] < n-i, increase i
        # else: decrease i
        l,r = 0,n-1
        while l+1 < r:
            mid = (l+r)//2
            if citations[mid] < n-mid:
                l = mid
            else:
                r = mid
        if citations[l]>=n-l: return n-l
        elif citations[r]>=n-r: return n-r
        return 0
```

## 1376. Time Needed to Inform All Employees ****

Complexity
Space: O(n).
Time: O(n).

```py
class Solution(object):
    def numOfMinutes(self, n, headID, manager, informTime):
        # reorder as adj list
        # DFS from head, reach the furthest node
        def dfs(nodeID,informTime):
            print(nodeID)
            time = 0
            for child in children[nodeID]:
                time = max(time,dfs(child,informTime))
            return time+informTime[nodeID]
        
        children = [[] for i in range(n)]
        for i in range(n):
            if manager[i] != -1:
                children[manager[i]].append(i)
        return dfs(headID,informTime)
        return 0
```

## 55. Jump Game ****
#### O(N^2)
```py
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        if n == 0: return False
        dp = [False for i in range(n+1)]
        dp[1] = True
        for i in range(n):
            if dp[i+1]:
                for j in range(1,nums[i]+1):
                    if i+1+j <=n:
                        dp[i+1+j] = True
        return dp[n]
```
#### Reduct to O(N)
```py
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        if n == 0: return False
        max_reach = 1
        for i in range(n):
            if i+1 <= max_reach:
                max_reach = max(max_reach,min(n,i+1+nums[i]))
        return True if max_reach == n else False
```
## 45. Jump Game II ****
O(N^2) TLE
用BFS的思路理解的。就像在一个图中寻找最短路径。一个数就是一个node，它的邻居就是它能reach到的那些点。最后写出来的代码跟greedy差不多。
```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int res = 0, n = nums.size(), i = 0, max_reach = 0;
        while (max_reach < n - 1) {
            ++res;
            int pre = max_reach;
            for (; i <= pre; ++i) {
                max_reach = max(max_reach, i + nums[i]);
            }
            if (pre == max_reach) return -1; // May not need this
        }
        return res;
    }
};
```


```py
class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0: return 0
        max_reach = 0
        i=0
        res = 0
        while max_reach <n-1:
            res += 1
            pre = max_reach
            while i <= pre:
                max_reach = max(max_reach,nums[i]+i)
                i+=1
            if max_reach == pre: return -1
        return res
```
## 1306. Jump Game III
```py
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        if arr[start] == 0: return True
        def dfs(pos,arr,visited=set()):
            if arr[pos] == 0: return True
            l,r = pos+arr[pos],pos-arr[pos]
            if l>=0 and l <len(arr) and l not in visited:
                visited.add(l)
                if dfs(l,arr,visited): return True
                visited.remove(l)
            if r>=0 and r <len(arr) and  r not in visited:
                visited.add(r)
                if dfs(r,arr,visited): return True
                visited.remove(r)
            return False
            
        if dfs(start,arr): return True
        return False
```

## 149. Best Time to Buy and Sell Stock
```py
class Solution:
    def maxProfit(self, prices):
        if not prices: return 0
        low = prices[0]
        res = 0
        for i in range(1,len(prices)):
            if prices[i] > low:
                res = max(res,prices[i]-low)
            else:
                low = prices[i]
        return res
```

## 150. Best Time to Buy and Sell Stock II
这道跟之前那道Best Time to Buy and Sell Stock 买卖股票的最佳时间很类似，但都比较容易解答。这道题由于可以无限次买入和卖出。我们都知道炒股想挣钱当然是低价买入高价抛出，那么这里我们只需要从第二天开始，如果当前价格比之前价格高，则把差值加入利润中，因为我们可以昨天买入，今日卖出，若明日价更高的话，还可以今日买入，明日再抛出。以此类推，遍历完整个数组后即可求得最大利润。代码如下：
```py
class Solution:
    def maxProfit(self, prices):
        n = len(prices)
        res = 0
        for i in range(n-1):
            if prices[i+1] > prices[i]:
                res += prices[i+1]-prices[i]
        return res
```
```py
class Solution:
    def maxProfit(self, prices):
        n = len(prices)
        if n < 2: return 0
        hi,lo=-1,-1
        res = 0
        for price in prices:
            if lo == -1 or (hi == -1 and lo > price):
                lo = price
            elif hi == -1 or price > hi:
                hi = price
            elif price < hi:
                res += hi-lo
                lo = price
                hi = -1
            # print(lo,hi,res)
        if hi > lo:
            res += hi-lo
        return res       
```
## 151. Best Time to Buy and Sell Stock III
```py
class Solution:
    """
    @param prices: Given an integer array
    @return: Maximum profit
    """
    def maxProfit(self, prices):
        n = len(prices)
        dp_l = [0 for i in range(n)]
        dp_r = [0 for i in range(n)]
        lo_l = 9999999999
        hi_r = -lo_l
        for i in range(0,n):
            r_idx = n-1-i
            if i != 0:
                dp_l[i] = dp_l[i-1]
                dp_r[r_idx] = dp_r[r_idx+1]
            if prices[i] < lo_l:
               lo_l = prices[i]
            if prices[r_idx] > hi_r:
               hi_r = prices[r_idx]
            if prices[i] > lo_l:
               dp_l[i] = max(prices[i]-lo_l,dp_l[i])
            if prices[r_idx] < hi_r:
               dp_r[r_idx] = max(hi_r-prices[r_idx],dp_r[r_idx])
        res = 0
        for i in range(n):
            if i != n-1:
                res = max(dp_l[i]+dp_r[i+1],res)
            else:
                res = max(dp_l[i],res)
        return res
```

## 393. Best Time to Buy and Sell Stock IV
https://www.youtube.com/watch?v=oDhu5uGq_ic
```py
class Solution:
    def maxProfit(self, K, prices):
        if K == 0 or prices == []:
            return 0

        days = len(prices)
        num_transactions = K + 1  # 0th transaction up to and including kth transaction is considered.
    
        T = [[0 for _ in range(days)] for _ in range(num_transactions)]
    
        for transaction in range(1, num_transactions):
            max_diff = - prices[0]
            for day in range(1, days):
                T[transaction][day] = max(T[transaction][day - 1],  # No transaction
                                          prices[day] + max_diff)  # price on that day with max diff
                max_diff = max(max_diff,
                               T[transaction - 1][day] - prices[day])  # update max_diff
    
        return T[-1][-1]

```

In Lintcode, there is a case when K is larger than days, so we can use the method in 
Best Time to Buy and Sell Stock II, which will be O(N)


## 309	Best Time to Buy and Sell Stock with Cooldown
https://www.youtube.com/watch?v=oL6mRyTn56M
buy,sold或者cool在第i天的最大值

price的index因为数组的原因向左调整了1
1. `buy[i] = max(buy[i-1], cool[i-1]-prices[i-1]) 第i天持有股票的最大值是i-1天的持有的最大值或者在第i天买入的最大值`
2. `sold[i] = buy[i-1]+prices[i-1] 第i天卖出的最大值是i-1天还持有股票的最大值加上i天卖出的最大值`
3.`cool[i] = max(cool[i-1],sold[i-1]) 第i天不操作的最大值是前一天不操作的最大值加上前一天卖出的最大值`
4. 最后的结果是`max(sold[i],cool[i])是因为要让结果最大，最后的时候应该不持有任何股票，而buy的状态是持有股票的`
```py
class Solution:
    """
    @param prices: a list of integers
    @return: return a integer
    """
    def maxProfit(self, prices):
        n = len(prices)
        buy = [0 for i in range(n+1)]
        sold = [0 for i in range(n+1)]
        cool = [0 for i in range(n+1)]
        buy[0]=-99999999
        for i in range(1,n+1):
            buy[i] = max(buy[i-1], cool[i-1]-prices[i-1])
            sold[i] = buy[i-1]+prices[i-1]
            cool[i] = max(cool[i-1],sold[i-1])
        return max(cool[n],sold[n])
```


## Container with most water
#### Brute Force O(N^2)
```py
class Solution:
    def maxArea(self, height: List[int]) -> int:
        n = len(height)
        l,r = 0,n-1
        res = 0
        while l < r:
            res = max(res,(r-l)*min(height[r],height[l]))
            # print(l,r,res)
            if height[l] < height[r]: l+=1
            else: r-=1
        return res
```
## Trapping Rain Water
#### Brute Froce
For each pos, try to find the max_l and max_r, which is O(N) time complexity, for all postions do the same operation so totally O(N^2)
```py
class Solution:
    def trap(self, height: List[int]) -> int:
        res = 0
        n = len(height)
        for i in range(1,n-1):
            max_l,max_r = i,i
            for j in range(i-1,-1,-1):
                if height[j] > height[max_l]: max_l = j
            for j in range(i+1,n):
                if height[j] > height[max_r]: max_r = j
            res += (min(height[max_l],height[max_r])-height[i])
        return res
```
#### DP
https://leetcode.com/problems/trapping-rain-water/solution/
using the idea from brute force, we can try to find the max_l and max_r first, then for each postion
```py
class Solution:
    def trap(self, height: List[int]) -> int:
        # find the max from 0 to i
        n = len(height)
        max_l = [height[0] for i in range(n)]
        max_r = [height[n-1] for i in range(n)]
        for i in range(1,n):
            max_l[i] = max(max_l[i-1],height[i])
            max_r[n-1-i] = max(max_r[n-i],height[n-1-i])
        res = 0
        for i in range(1,n-1):
            res += min(max_l[i],max_r[i])-height[i]
        return res
```
#### Two pointer
Similiar to container with most water， the number of water trapped is determined by the smaller border, so we will always moves the smaller border.
```py
class Solution:
    def trap(self, height: List[int]) -> int:
        # two pointer, for each position, it is bounded by left and right position
        # when we minimize the border, the height of container will increase(similiar to contaienr with most water)
        n = len(height)
        res = 0
        max_l,max_r = 0,0
        l,r = 0,n-1
        while l<r:
            if height[l] < height[r]:
                if height[l] >= max_l:
                    max_l = height[l]
                else:
                    res += max_l - height[l]
                l += 1
            else:
                if height[r] >= max_r:
                    max_r = height[r]
                else:
                    res += max_r - height[r]
                r -= 1
        return res
```

## Trapping Rain Water II

#### 直接二维DP
直接计算一个矩形的最小值是错误的，因为最后桶的形状可能不是矩形，如果按照矩形算会偏大
```py
class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -> int:
        # 2D trapping rain water
        # 2D dp
        m = len(heightMap)
        if not m: return 0
        n = len(heightMap[0])
        if not n: return 0
        dp_l_r = [[0 for i in range(n)] for j in range(m)]
        dp_r_l = [[0 for i in range(n)] for j in range(m)]
        dp_u_d = [[0 for i in range(n)] for j in range(m)]
        dp_d_u = [[0 for i in range(n)] for j in range(m)]
        for i in range(m):
            for j in range(n):
                if j == 0:
                    dp_l_r[i][j] = heightMap[i][j]
                    dp_r_l[i][n-1-j] = heightMap[i][n-1-j]
                else:
                    dp_l_r[i][j] = max(dp_l_r[i][j-1],heightMap[i][j]) 
                    dp_r_l[i][n-1-j] = max(dp_r_l[i][n-j],heightMap[i][n-1-j])
        for j in range(n):
            for i in range(m):
                if i == 0:
                    dp_u_d[i][j] = heightMap[i][j]
                    dp_d_u[m-1-i][j] = heightMap[m-1-i][j]
                else:
                    dp_u_d[i][j] = max(dp_u_d[i-1][j],heightMap[i][j])
                    dp_d_u[m-1-i][j] = max(dp_d_u[m-i][j],heightMap[m-1-i][j])
        res = 0
        for i in range(1,m-1):
            for j in range(1,n-1):
                if min(dp_l_r[i][j], dp_r_l[i][j], dp_u_d[i][j], dp_d_u[i][j]) > heightMap[i][j] or (i == 1 and j == 4):
                    print((i,j),dp_l_r[i][j], dp_r_l[i][j], dp_u_d[i][j], dp_d_u[i][j],heightMap[i][j])
                res += min(dp_l_r[i][j], dp_r_l[i][j], dp_u_d[i][j], dp_d_u[i][j])-heightMap[i][j]
        return res
```
#### BFS+priority_queue
对于一维来说，当我们从两个端点往中间走的时候，水位一定是单调不递减的。因为[x1, x2]之间的水位，一定是大于等于min(height[x1], height[x2])的。如果x1, x2之间有更低的bar，则不影响水位，如果有更高的bar，那么只会让水位上涨。因此当我们从两头往中间走的时候，可以一直更新当前的水位，并且计算当前经过的位置所能积蓄的水量。

对于二维来说，一个重要的注意点就是我们不再是从两个端点走，而是要更新一个二维平面里的边界，而且这个边界不一定是标准的矩形，而可能是任意的多边形。因此我们每次都要找到当前边界里最低的那个点X，依据X的高度更新水位高度，并且找到它周围没有被计算过的邻居。这些邻居具备两个特质：1.他们如果可以储水，那么水位的高度一定是当前水位的高度。2. 将X移出边界后，这些邻居成为了新的边界的一部分。对于如何找当前边界里高度最低的点，我们可以将边界里的所有点都保存一个priority_queue中。

先扫描一遍边界（除了四个角），获得了一个基础的边界，然后从最低点开始往外走，如果最低点的旁边的点高度比它低，那么可以储水，如果比它高，那么成为新的边界，把它旁边的点加入到priority queue，不断扫描直到priority queue为空

```cpp
class Solution {
public:
    int trapRainWater(vector<vector<int>>& heightMap) {
        if(heightMap.size()==0) return 0;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> que;
        int row = heightMap.size(), col = heightMap[0].size();
        vector<vector<int>> visited(row, vector<int>(col, 0));
        int ans = 0, Max = INT_MIN;
        for(int i = 0; i < row; i++) {
            for(int j = 0; j < col; j++) {
                if(!(i==0 || i==row-1 || j==0 || j==col-1)) continue;
                que.push(make_pair(heightMap[i][j], i*col+j));
                visited[i][j] = 1;
            }
        }
        vector<vector<int>> dir{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        while(!que.empty()) {
            auto val = que.top(); que.pop();
            int height = val.first, x = val.second/col, y = val.second%col;
            Max = max(Max, height);
            for(auto d: dir) {
                int x2 = x + d[0], y2 = y + d[1];
                if(x2>=row || x2<0 || y2<0 || y2>=col || visited[x2][y2]) continue;
                visited[x2][y2] = 1;
                if(heightMap[x2][y2] < Max) ans += Max - heightMap[x2][y2];
                que.push(make_pair(heightMap[x2][y2], x2*col+y2));
            }
        }
        return ans;
    }
};
```

## 334. Increasing Triplet Subsequence
注意必须是sub-sequence，所以要保持顺序。

要保证`a<b<c`的关系，所以考虑O(N)扫一遍数组，如果大于b，那么找到了结果，如果大于a（注意不能是等于，否则失去了`a<b`的特性）那么更新b。否则的话遇到了一个更小的a，更新a，这里更新以后a比b小，但如果遇到了一个数字比b大，那么由于更新前的a是比b小的，所以仍然满足找到`a<b<c`。
```py
class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        a = b = 99999999999
        for num in nums:
            # < a >= a < b  
            # if > b: return True
            if num > b: return True
            elif num > a: b = num
            else: a = num
        return False
```