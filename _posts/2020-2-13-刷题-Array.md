---
layout: post
title:  Python Array
categories: Interview
---
## 1353. Maximum Number of Events That Can Be Attended
```java
class Solution {
        public int maxEvents(int[][] events) {
        Arrays.sort(events, (a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]);
        int count = 0;
        boolean[] attended = new boolean[100001];
        
        for (int[] event : events) 
            for (int i = event[0]; i <= event[1]; i++) 
                if (attended[i] == false) {
                    attended[i] = true;
                    count++;
                    break;
                }

        
        return count;
    }
}
```

## 27	Remove Element
```py
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        idx = 0
        for i in range(len(nums)):
            if nums[i] != val:
                nums[idx] = nums[i]
                idx+=1
        return idx
```

## 26. Remove Duplicates from Sorted Array
```py
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        idx = 0
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i-1]: continue
            nums[idx] = nums[i]
            idx += 1
        return idx
```

## 80. Remove Duplicates from Sorted Array II
Can't do `nums[i] == nums[i-2]`, because postions before i may be modified, the index is not reliable
```py
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        idx = 0
        for i in range(len(nums)):
            if i+2 < len(nums) and nums[i] == nums[i+2]: 
                continue
            nums[idx] = nums[i]
            idx += 1
        return idx
```

## 645. Find the Celebrity
```py
class Solution:
    # @param {int} n a party with n people
    # @return {int} the celebrity's label or -1
    def findCelebrity(self, n):
        # flag means if i is celebrity
        flag = [True for i in range(n)]
        for i in range(n):
            for j in range(n):
                if i == j: continue
                ret =  Celebrity.knows(i,j)
                if ret == True:
                    flag[i] = False
                if ret == False:
                    flag[j] = False
        for i in range(n):
            if flag[i]: return i
        return -1
```

## Rotate Array
根据热心网友 waruzhi 的留言，这道题其实还有种类似翻转字符的方法，思路是先把前 n-k 个数字翻转一下，再把后k个数字翻转一下，最后再把整个数组翻转一下：
```py
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        # 1 2 3 4 5 6 7   k  = 3
        # 5 6 7 1 2 3 4
        # reverse first n-k, last k and reverse the whole thing
        if not nums or k%(len(nums))==0: return 0
        def reverse(nums,l,r):
            while l < r:
                nums[l],nums[r] = nums[r],nums[l]
                l+=1
                r-=1
        k = k % len(nums)
        midPoint = len(nums)-k-1
        reverse(nums,0,midPoint)
        reverse(nums,midPoint+1,len(nums)-1)
        reverse(nums,0,len(nums)-1)
```

## 41. First Missing Positive  ****
注意是first missing postive，所以对于0...N-1，一定会有一个数miss. And negative number and 0 are useless
becasue O(n) time and no extra space, think of modify origin array

#### O(N) space
用O(N)space 的bool array即可
 
#### O(1) space
https://www.youtube.com/watch?v=8DqewGsVNkI
```py
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        INF = len(nums)+1
        n = len(nums)
        if not n: return 1
        for i in range(n):
            if nums[i] <=0 or nums[i] > n : nums[i] = INF
        for i in range(n):
            print(nums)
            v = abs(nums[i])
            if v == INF: continue
            if nums[v-1] > 0: nums[v-1] = -nums[v-1]
            
        for i in range(n):
            if nums[i] > 0: return i+1
        return INF
```

## 299. Bulls and Cows
```py
class Solution:
    def getHint(self, secret, guess):
        bulls = sum(map(operator.eq, secret, guess))
        both = sum(min(secret.count(x), guess.count(x)) for x in set(guess))
        return '%dA%dB' % (bulls, both - bulls)
```

## 134. Gas Station
```py
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        #O(N^2) simulate?
        n = len(gas)
        # n start positions
        for start in range(0,n):
            # move m times
            cur_gas = gas[start]
            cur_idx = start
            cnt = 0
            while cnt < n:                
                # print("Start at %d,cur_idx=%d,cur_gas=%d,next_gas=%d"%(start,cur_idx,cur_gas,cur_gas-cost[cur_idx]))
                if cur_gas < cost[cur_idx]:
                    break
                cur_gas -= cost[cur_idx]
                next_idx = (cur_idx+1)%n
                cur_idx = next_idx
                cur_gas += gas[cur_idx]
                cnt += 1
            if cnt == n:
                return start
        return -1
```

## 118. Pascal's Triangle
```py
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        res = []
        if numRows == 0: return res
        res = [[1]]        
        for i in range(1,numRows):
            cur_row = [1]
            for j in range(1,len(res[-1])):
                cur_row.append(res[-1][j]+res[-1][j-1])
            cur_row.append(1)
            res += [cur_row]
        return res
```

## 119. Pascal's Triangle II
```py
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        if rowIndex == 0: return [1]
        pre = [[1]]
        for i in range(rowIndex):
            cur_row = [1]
            for j in range(1,len(pre)):
                cur_row.append(pre[j]+pre[j-1])
            cur_row.append(1)
            pre = cur_row
        return pre
```

## 169. Majority Element
#### Hash map: very simple
#### Voteing algorithm
```py
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        cnt=0
        cur=-1
        first = True
        for num in nums:
            if first:
                first = False
            else:
                if cur == num:
                    cnt += 1
                else:
                    cnt -= 1
            if cnt == 0:
                cnt = 1
                cur = num
        return cur
```

## 229. Majority Element II ****
For those who aren't familiar with Boyer-Moore Majority Vote algorithm,
I found a great article (http://goo.gl/64Nams) that helps me to understand this fantastic algorithm!!
Please check it out!

The essential concepts is you keep a counter for the majority number X. If you find a number Y that is not X, the current counter should deduce 1. The reason is that if there is 5 X and 4 Y, there would be one (5-4) more X than Y. This could be explained as "4 X being paired out by 4 Y".

And since the requirement is finding the majority for more than ceiling of [n/3], the answer would be less than or equal to two numbers.
So we can modify the algorithm to maintain two counters for two majorities.

Followings are my sample Python code:
```py
class Solution:
# @param {integer[]} nums
# @return {integer[]}
def majorityElement(self, nums):
    if not nums:
        return []
    count1, count2, candidate1, candidate2 = 0, 0, 0, 1
    for n in nums:
        if n == candidate1:
            count1 += 1
        elif n == candidate2:
            count2 += 1
        elif count1 == 0:
            candidate1, count1 = n, 1
        elif count2 == 0:
            candidate2, count2 = n, 1
        else:
            count1, count2 = count1 - 1, count2 - 1
    return [n for n in (candidate1, candidate2)
                    if nums.count(n) > len(nums) // 3]
```

@liji94188 said in Boyer-Moore Majority Vote algorithm and my elaboration:

Great algorithm, but need some more explanation on the confusing word 2 "majorities". They are not necessarily be the 2 most frequent elements after the 1st round. Here is why the poster's 2 "majorities" algorithm really works:
consider 3 cases:

1. there are no elements that appears more than n/3 times, then whatever the algorithm 
 got from 1st round wound be rejected in the second round.
2. there are only one elements that appears more than n/3 times, after 1st round one of 
 the candicate must be that appears more than n/3 times(<2n/3 other elements could only
 pair out for <n/3 times), the other candicate is not necessarily be the second most frequent 
 but it would be rejected in 2nd round.
3. there are two elments appears more than n/3 times, candicates would contain both of
 them. (<n/3 other elements couldn't pair out any of the majorities.)
I will explain to people who don't understand his second claim, which took me a long time to understand. ;)

First, we claim: given n numbers and the k counters, only less than n/(k+1) times pair-out can happen.
That is to say:

given n numbers and 1 counter (which is the majority element problem), at most (n/2) times pair-out can happen, which will lead to the survival of the only element that appeared more than n/2 times.
given n numbers and 2 counters (which is our case), at most n/3 times of pair-out can happen, which will lead to the survival of elements that appeared more than n/3 times.
given n numbers and k counters, at most (n/k+1) times of pair-out can happen, which will lead to the survival of elements that appeared more than n/(k+1) times.
If this is the case, then n elements using two counters can at most pair out less than (n/3) times, which will result in the survival of the elements that appears more than (n/3) times.

First we look at an example of one counter:
suppose nums = [1, 2, 3, 4, 5, 6], and we are finding only one candidate and we have only one counter.

the procedure will be like this:

candidate = 1, counter = 1

current number = 2
candidate = 1, counter = 0
(one pair-out happens)

current number = 3
candidate = 3, counter = 1
(pair-out cannot happen now since there's nothing to pair out! Instead, counter got increased!)

current number = 4
candidate = 3, counter = 0
(one pair-out happens)

current number = 5
candidate = 5, counter = 1
(pair-out cannot happen and counter increased!)

curent number = 6
candidate = 5, counter = 0
(one pair-out happens)

From the above example, there are 6 elements in nums and we paired out 3 times, which is the most we can get. Suppose nums = [1,1,1,1,2,3], now we see that pair-out can happen only twice in this case.

From the above example, it's obvious that to pair out once, you have to increase the counter at least once.
And to pair out some candidate, you need first increase the counter. And every time you increase the counter, you waste one chance to pair out. So given n numbers, you can at most pair out (n/2) times, since you have to at least increase the counter (n/2) times to let you have something to pair out. It's quite like the amortized analysis, but if you don't know that, it doesn't matter though.

Now we still use the example above but we hope to find two candidates:
suppose nums = [1, 2, 3, 4, 5, 6], and we are finding two candidates and we have two counters.

the procedure will be like this:

candidate1 = 1, counter1 = 1
candidate2 = 2, counter2 = 1

current number = 3
candidate1 = 1, counter1 = 0
candidate2 = 2, counter2 = 0
(one pair-out happens and both counters got decreased.)

current number = 4
candidate1 = 4, counter = 1
candidate2 = 2, counter2 = 0
(pair-out cannot happen and counter1 got increased)

current number = 5
candidate1 = 4, counter1 = 1
candidate2 = 5, counter2 = 1
(pair-out can still not happen and counter2 got incresed)

current number = 6
candidate1 = 4, counter1 = 0
candidate2 = 5, counter2 = 0
(pair-out happens and both counters become 0)

Now we see, there are 6 elements in nums and we paired out 2 times, which is also the most we can get. Suppose nums = [1,1,1,1,2,3], pair-out can happen only once in this case.

This is because once pair-out happens, both counters decrease. And when some counter becomes 0, only one counter will get increased at a time. So to pair out m times, each counter have to be increased at least m times, which is to increase 2*m times totally.

It's not difficult to generalize to k counters. Of course, when k is large, it may be not efficient to use this count-and-pair-out method. However, the algorithm is still worth learning.

Hope it helps :)


要求O(1)空间，投票
```py
class Solution:
    def majorityElement(self, nums: List[int]) -> List[int]:
        INF = 99999999999
        a,b,cnt1,cnt2=INF,INF,0,0
        for num in nums:
            if num == a: cnt1+=1
            elif num == b: cnt2+=1
            elif cnt1 == 0: 
                a = num
                cnt1 = 1
            elif cnt2 == 0: 
                b = num
                cnt2 = 1
            else:
                cnt1 -=1
                cnt2 -=1
        cnt1,cnt2 = 0,0
        for num in nums:
            if num == a: cnt1 += 1
            elif num == b: cnt2 += 1
        res = []
        if cnt1 > len(nums)//3: res.append(a)
        if cnt2 > len(nums)//3: res.append(b)
        return res
```

## 274. H-Index
```py
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        citations.sort()
        n = len(citations)
        for i in range(n):
            h = n-i
            if citations[i] >= h:
                return h
        return 0
```
## 275. H-Index II
```py
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        if n == 0: return 0
        # find the position where nums[i] >= n-i
        # if nums[i] < n-i, increase i
        # else: decrease i
        l,r = 0,n-1
        while l+1 < r:
            mid = (l+r)//2
            if citations[mid] < n-mid:
                l = mid
            else:
                r = mid
        if citations[l]>=n-l: return n-l
        elif citations[r]>=n-r: return n-r
        return 0
```

## 1376. Time Needed to Inform All Employees ****

Complexity
Space: O(n).
Time: O(n).

```py
class Solution(object):
    def numOfMinutes(self, n, headID, manager, informTime):
        # reorder as adj list
        # DFS from head, reach the furthest node
        def dfs(nodeID,informTime):
            print(nodeID)
            time = 0
            for child in children[nodeID]:
                time = max(time,dfs(child,informTime))
            return time+informTime[nodeID]
        
        children = [[] for i in range(n)]
        for i in range(n):
            if manager[i] != -1:
                children[manager[i]].append(i)
        return dfs(headID,informTime)
        return 0
```

## 42. Trapping Rain Water
#### brute force
For each index, scan left and right and find the max of left and right, the resulet is 
`max(left,right)-height[idx]`
```py
class Solution:
    def trap(self, height: List[int]) -> int:
        # brute force: scan for each pos
        n = len(height)
        res = 0
        for i in range(1,n-1):
            mx_l,mx_r = i,i
            for j in range(i-1,-1,-1):
                if height[j] > height[mx_l]:
                    mx_l = j
            for j in range(i+1,n):
                if height[j] > height[mx_r]:
                    mx_r = j
            res += (min(height[mx_l],height[mx_r])-height[i])
        return res
```
## 55. Jump Game ****
#### O(N^2)
```py
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        if n == 0: return False
        dp = [False for i in range(n+1)]
        dp[1] = True
        for i in range(n):
            if dp[i+1]:
                for j in range(1,nums[i]+1):
                    if i+1+j <=n:
                        dp[i+1+j] = True
        return dp[n]
```
#### Reduct to O(N)
```py
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        if n == 0: return False
        max_reach = 1
        for i in range(n):
            if i+1 <= max_reach:
                max_reach = max(max_reach,min(n,i+1+nums[i]))
        return True if max_reach == n else False
```
## 45. Jump Game II ****
O(N^2) TLE
用BFS的思路理解的。就像在一个图中寻找最短路径。一个数就是一个node，它的邻居就是它能reach到的那些点。最后写出来的代码跟greedy差不多。
```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int res = 0, n = nums.size(), i = 0, max_reach = 0;
        while (max_reach < n - 1) {
            ++res;
            int pre = max_reach;
            for (; i <= pre; ++i) {
                max_reach = max(max_reach, i + nums[i]);
            }
            if (pre == max_reach) return -1; // May not need this
        }
        return res;
    }
};
```


```py
class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0: return 0
        max_reach = 0
        i=0
        res = 0
        while max_reach <n-1:
            res += 1
            pre = max_reach
            while i <= pre:
                max_reach = max(max_reach,nums[i]+i)
                i+=1
            if max_reach == pre: return -1
        return res
```
## 1306. Jump Game III
```py
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        if arr[start] == 0: return True
        def dfs(pos,arr,visited=set()):
            if arr[pos] == 0: return True
            l,r = pos+arr[pos],pos-arr[pos]
            if l>=0 and l <len(arr) and l not in visited:
                visited.add(l)
                if dfs(l,arr,visited): return True
                visited.remove(l)
            if r>=0 and r <len(arr) and  r not in visited:
                visited.add(r)
                if dfs(r,arr,visited): return True
                visited.remove(r)
            return False
            
        if dfs(start,arr): return True
        return False
```

## 149. Best Time to Buy and Sell Stock
```py
class Solution:
    def maxProfit(self, prices):
        if not prices: return 0
        low = prices[0]
        res = 0
        for i in range(1,len(prices)):
            if prices[i] > low:
                res = max(res,prices[i]-low)
            else:
                low = prices[i]
        return res
```

## 150. Best Time to Buy and Sell Stock II
这道跟之前那道Best Time to Buy and Sell Stock 买卖股票的最佳时间很类似，但都比较容易解答。这道题由于可以无限次买入和卖出。我们都知道炒股想挣钱当然是低价买入高价抛出，那么这里我们只需要从第二天开始，如果当前价格比之前价格高，则把差值加入利润中，因为我们可以昨天买入，今日卖出，若明日价更高的话，还可以今日买入，明日再抛出。以此类推，遍历完整个数组后即可求得最大利润。代码如下：
```py
class Solution:
    def maxProfit(self, prices):
        n = len(prices)
        res = 0
        for i in range(n-1):
            if prices[i+1] > prices[i]:
                res += prices[i+1]-prices[i]
        return res
```
```py
class Solution:
    def maxProfit(self, prices):
        n = len(prices)
        if n < 2: return 0
        hi,lo=-1,-1
        res = 0
        for price in prices:
            if lo == -1 or (hi == -1 and lo > price):
                lo = price
            elif hi == -1 or price > hi:
                hi = price
            elif price < hi:
                res += hi-lo
                lo = price
                hi = -1
            # print(lo,hi,res)
        if hi > lo:
            res += hi-lo
        return res       
```
## 151. Best Time to Buy and Sell Stock III
```py
class Solution:
    """
    @param prices: Given an integer array
    @return: Maximum profit
    """
    def maxProfit(self, prices):
        n = len(prices)
        dp_l = [0 for i in range(n)]
        dp_r = [0 for i in range(n)]
        lo_l = 9999999999
        hi_r = -lo_l
        for i in range(0,n):
            r_idx = n-1-i
            if i != 0:
                dp_l[i] = dp_l[i-1]
                dp_r[r_idx] = dp_r[r_idx+1]
            if prices[i] < lo_l:
               lo_l = prices[i]
            if prices[r_idx] > hi_r:
               hi_r = prices[r_idx]
            if prices[i] > lo_l:
               dp_l[i] = max(prices[i]-lo_l,dp_l[i])
            if prices[r_idx] < hi_r:
               dp_r[r_idx] = max(hi_r-prices[r_idx],dp_r[r_idx])
        res = 0
        for i in range(n):
            if i != n-1:
                res = max(dp_l[i]+dp_r[i+1],res)
            else:
                res = max(dp_l[i],res)
        return res
```

## 393. Best Time to Buy and Sell Stock IV
https://www.youtube.com/watch?v=oDhu5uGq_ic
```py
class Solution:
    def maxProfit(self, K, prices):
        if K == 0 or prices == []:
            return 0

        days = len(prices)
        num_transactions = K + 1  # 0th transaction up to and including kth transaction is considered.
    
        T = [[0 for _ in range(days)] for _ in range(num_transactions)]
    
        for transaction in range(1, num_transactions):
            max_diff = - prices[0]
            for day in range(1, days):
                T[transaction][day] = max(T[transaction][day - 1],  # No transaction
                                          prices[day] + max_diff)  # price on that day with max diff
                max_diff = max(max_diff,
                               T[transaction - 1][day] - prices[day])  # update max_diff
    
        return T[-1][-1]

```

In Lintcode, there is a case when K is larger than days, so we can use the method in 
Best Time to Buy and Sell Stock II, which will be O(N)


## 309	Best Time to Buy and Sell Stock with Cooldown
https://www.youtube.com/watch?v=oL6mRyTn56M
buy,sold或者cool在第i天的最大值

price的index因为数组的原因向左调整了1
1. `buy[i] = max(buy[i-1], cool[i-1]-prices[i-1]) 第i天持有股票的最大值是i-1天的持有的最大值或者在第i天买入的最大值`
2. `sold[i] = buy[i-1]+prices[i-1] 第i天卖出的最大值是i-1天还持有股票的最大值加上i天卖出的最大值`
3.`cool[i] = max(cool[i-1],sold[i-1]) 第i天不操作的最大值是前一天不操作的最大值加上前一天卖出的最大值`
4. 最后的结果是`max(sold[i],cool[i])是因为要让结果最大，最后的时候应该不持有任何股票，而buy的状态是持有股票的`
```py
class Solution:
    """
    @param prices: a list of integers
    @return: return a integer
    """
    def maxProfit(self, prices):
        n = len(prices)
        buy = [0 for i in range(n+1)]
        sold = [0 for i in range(n+1)]
        cool = [0 for i in range(n+1)]
        buy[0]=-99999999
        for i in range(1,n+1):
            buy[i] = max(buy[i-1], cool[i-1]-prices[i-1])
            sold[i] = buy[i-1]+prices[i-1]
            cool[i] = max(cool[i-1],sold[i-1])
        return max(cool[n],sold[n])
```


## Container with most water
#### Brute Force O(N^2)
```py
class Solution:
    def maxArea(self, height: List[int]) -> int:
        n = len(height)
        l,r = 0,n-1
        res = 0
        while l < r:
            res = max(res,(r-l)*min(height[r],height[l]))
            # print(l,r,res)
            if height[l] < height[r]: l+=1
            else: r-=1
        return res
```
## Trapping Rain Water
#### Brute Froce
For each pos, try to find the max_l and max_r, which is O(N) time complexity, for all postions do the same operation so totally O(N^2)
```py
class Solution:
    def trap(self, height: List[int]) -> int:
        res = 0
        n = len(height)
        for i in range(1,n-1):
            max_l,max_r = i,i
            for j in range(i-1,-1,-1):
                if height[j] > height[max_l]: max_l = j
            for j in range(i+1,n):
                if height[j] > height[max_r]: max_r = j
            res += (min(height[max_l],height[max_r])-height[i])
        return res
```
#### DP
https://leetcode.com/problems/trapping-rain-water/solution/
using the idea from brute force, we can try to find the max_l and max_r first, then for each postion
```py
class Solution:
    def trap(self, height: List[int]) -> int:
        # find the max from 0 to i
        n = len(height)
        max_l = [height[0] for i in range(n)]
        max_r = [height[n-1] for i in range(n)]
        for i in range(1,n):
            max_l[i] = max(max_l[i-1],height[i])
            max_r[n-1-i] = max(max_r[n-i],height[n-1-i])
        res = 0
        for i in range(1,n-1):
            res += min(max_l[i],max_r[i])-height[i]
        return res
```
#### Two pointer
Similiar to container with most water， the number of water trapped is determined by the smaller border, so we will always moves the smaller border.
```py
class Solution:
    def trap(self, height: List[int]) -> int:
        # two pointer, for each position, it is bounded by left and right position
        # when we minimize the border, the height of container will increase(similiar to contaienr with most water)
        n = len(height)
        res = 0
        max_l,max_r = 0,0
        l,r = 0,n-1
        while l<r:
            if height[l] < height[r]:
                if height[l] >= max_l:
                    max_l = height[l]
                else:
                    res += max_l - height[l]
                l += 1
            else:
                if height[r] >= max_r:
                    max_r = height[r]
                else:
                    res += max_r - height[r]
                r -= 1
        return res
```

## Trapping Rain Water II

#### 直接二维DP
直接计算一个矩形的最小值是错误的，因为最后桶的形状可能不是矩形，如果按照矩形算会偏大
```py
class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -> int:
        # 2D trapping rain water
        # 2D dp
        m = len(heightMap)
        if not m: return 0
        n = len(heightMap[0])
        if not n: return 0
        dp_l_r = [[0 for i in range(n)] for j in range(m)]
        dp_r_l = [[0 for i in range(n)] for j in range(m)]
        dp_u_d = [[0 for i in range(n)] for j in range(m)]
        dp_d_u = [[0 for i in range(n)] for j in range(m)]
        for i in range(m):
            for j in range(n):
                if j == 0:
                    dp_l_r[i][j] = heightMap[i][j]
                    dp_r_l[i][n-1-j] = heightMap[i][n-1-j]
                else:
                    dp_l_r[i][j] = max(dp_l_r[i][j-1],heightMap[i][j]) 
                    dp_r_l[i][n-1-j] = max(dp_r_l[i][n-j],heightMap[i][n-1-j])
        for j in range(n):
            for i in range(m):
                if i == 0:
                    dp_u_d[i][j] = heightMap[i][j]
                    dp_d_u[m-1-i][j] = heightMap[m-1-i][j]
                else:
                    dp_u_d[i][j] = max(dp_u_d[i-1][j],heightMap[i][j])
                    dp_d_u[m-1-i][j] = max(dp_d_u[m-i][j],heightMap[m-1-i][j])
        res = 0
        for i in range(1,m-1):
            for j in range(1,n-1):
                if min(dp_l_r[i][j], dp_r_l[i][j], dp_u_d[i][j], dp_d_u[i][j]) > heightMap[i][j] or (i == 1 and j == 4):
                    print((i,j),dp_l_r[i][j], dp_r_l[i][j], dp_u_d[i][j], dp_d_u[i][j],heightMap[i][j])
                res += min(dp_l_r[i][j], dp_r_l[i][j], dp_u_d[i][j], dp_d_u[i][j])-heightMap[i][j]
        return res
```
#### BFS+priority_queue
对于一维来说，当我们从两个端点往中间走的时候，水位一定是单调不递减的。因为[x1, x2]之间的水位，一定是大于等于min(height[x1], height[x2])的。如果x1, x2之间有更低的bar，则不影响水位，如果有更高的bar，那么只会让水位上涨。因此当我们从两头往中间走的时候，可以一直更新当前的水位，并且计算当前经过的位置所能积蓄的水量。

对于二维来说，一个重要的注意点就是我们不再是从两个端点走，而是要更新一个二维平面里的边界，而且这个边界不一定是标准的矩形，而可能是任意的多边形。因此我们每次都要找到当前边界里最低的那个点X，依据X的高度更新水位高度，并且找到它周围没有被计算过的邻居。这些邻居具备两个特质：1.他们如果可以储水，那么水位的高度一定是当前水位的高度。2. 将X移出边界后，这些邻居成为了新的边界的一部分。对于如何找当前边界里高度最低的点，我们可以将边界里的所有点都保存一个priority_queue中。

先扫描一遍边界（除了四个角），获得了一个基础的边界，然后从最低点开始往外走，如果最低点的旁边的点高度比它低，那么可以储水，如果比它高，那么成为新的边界，把它旁边的点加入到priority queue，不断扫描直到priority queue为空

```cpp
class Solution {
public:
    int trapRainWater(vector<vector<int>>& heightMap) {
        if(heightMap.size()==0) return 0;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> que;
        int row = heightMap.size(), col = heightMap[0].size();
        vector<vector<int>> visited(row, vector<int>(col, 0));
        int ans = 0, Max = INT_MIN;
        for(int i = 0; i < row; i++) {
            for(int j = 0; j < col; j++) {
                if(!(i==0 || i==row-1 || j==0 || j==col-1)) continue;
                que.push(make_pair(heightMap[i][j], i*col+j));
                visited[i][j] = 1;
            }
        }
        vector<vector<int>> dir{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        while(!que.empty()) {
            auto val = que.top(); que.pop();
            int height = val.first, x = val.second/col, y = val.second%col;
            Max = max(Max, height);
            for(auto d: dir) {
                int x2 = x + d[0], y2 = y + d[1];
                if(x2>=row || x2<0 || y2<0 || y2>=col || visited[x2][y2]) continue;
                visited[x2][y2] = 1;
                if(heightMap[x2][y2] < Max) ans += Max - heightMap[x2][y2];
                que.push(make_pair(heightMap[x2][y2], x2*col+y2));
            }
        }
        return ans;
    }
};
```

## 334. Increasing Triplet Subsequence
注意必须是sub-sequence，所以要保持顺序。

要保证`a<b<c`的关系，所以考虑O(N)扫一遍数组，如果大于b，那么找到了结果，如果大于a（注意不能是等于，否则失去了`a<b`的特性）那么更新b。否则的话遇到了一个更小的a，更新a，这里更新以后a比b小，但如果遇到了一个数字比b大，那么由于更新前的a是比b小的，所以仍然满足找到`a<b<c`。
```py
class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        a = b = 99999999999
        for num in nums:
            # < a >= a < b  
            # if > b: return True
            if num > b: return True
            elif num > a: b = num
            else: a = num
        return False
```

## 128. Longest Consecutive Sequence
#### Union Find
for each time we see a number, find if its neightbos are visited, if so, we union those two numbers and update the counter. Since we only union find nearby numbers, the find_parent and add count would only be 
```py
class Node:
    def __init__(self,idx):
        self.idx = idx
        self.pre = idx
        self.count = 1
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        # pre should be the index
        # val is its own index
        def find_root(nodes,node):
            if node.idx != node.pre:
                node.pre = find_root(nodes,nodes[node.pre])
            return node.pre
        def union(nodes,idx_1,idx_2):
            nodes[idx_1].pre = nodes[idx_2].pre
            nodes[idx_2].count += nodes[idx_1].count
        nodes = []
        n = len(nums)
        for i in range(n):
            nodes.append(Node(i))
        visited = {}
        for i in range(n):
            if nums[i] in visited: continue
            else: 
                visited[nums[i]] = i
                for x in {-1,1}:
                    if nums[i]+x in visited:
                        root_a = find_root(nodes,nodes[i])
                        root_b = find_root(nodes,nodes[visited[nums[i]+x]])
                        union(nodes,root_a,root_b)
        res = 0
        for i in range(n):
            if nodes[i].idx == nodes[i].pre:
                res = max(res,nodes[i].count)
        return res
```

#### Simple hash set
这道题要求求最长连续序列，并给定了O(n)复杂度限制，我们的思路是，使用一个集合HashSet存入所有的数字，然后遍历数组中的每个数字，如果其在集合中存在，那么将其移除，然后分别用两个变量pre和next算出其前一个数跟后一个数，然后在集合中循环查找，如果pre在集合中，那么将pre移除集合，然后pre再自减1，直至pre不在集合之中，对next采用同样的方法，那么next-pre-1就是当前数字的最长连续序列，更新res即可。这里再说下，为啥当检测某数字在集合中存在当时候，都要移除数字。这是为了避免大量的重复计算，就拿题目中的例子来说吧，我们在遍历到4的时候，会向下遍历3，2，1，如果都不移除数字的话，遍历到1的时候，还会遍历2，3，4。同样，遍历到3的时候，向上遍历4，向下遍历2，1，等等等。如果数组中有大量的连续数字的话，那么就有大量的重复计算，十分的不高效，所以我们要从HashSet中移除数字，代码如下：
```py
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        n = len(nums)
        visited = set()
        for i in range(n):
            visited.add(nums[i])
        res = 0
        for i in range(n):
            if nums[i] not in visited: continue
            visited.remove(nums[i])
            l,r = nums[i]-1,nums[i]+1
            length = 0
            while l in visited:
                visited.remove(l)
                l-=1
            while r in visited:
                visited.remove(r)
                r+=1
            # because finally l and r are not in visited, and because we remove them from visited, each number is only visited once,
            # So we reach O(N) time complexity
            res = max(r-l-1,res)
        return res
```

## 1383. Maximum Performance of a Team
Same ideal with 857. Minimum Cost to Hire K Workers.

`Performance = sum(speed) * min(efficiency)`. Idea is simple: try every efficiency value from highest to lowest, keep adding speed to total speed, if size of engineers group exceeds K, lay off the engineer with lowest speed.

1. Sort efficiency with descending order. Because, afterwards, when we iterate whole engineers, every round, when calculating the current performance, minimum efficiency is the effiency of the new incoming engineer.
2. Maintain a pq to track of the minimum speed in the group. If size of group is == K, kick the engineer with minimum speed out (since efficiency is fixed by new coming engineer, the only thing matters now is sum of speed).
3. Calculate/Update performance.

```py
class Solution:
    def maxPerformance(self, n, speed, efficiency, k):
        h = []
        res = sSum = 0
        for e, s in sorted(zip(efficiency, speed), reverse=1):
            heapq.heappush(h, s)
            sSum += s
            if len(h) > k:
                sSum -= heapq.heappop(h)
            # because we sort the array with hight efficiency, so the current effciency is the lowest
            res = max(res, sSum * e)
        return res % (10**9 + 7)
```

```cpp
int maxPerformance(int n, vector<int>& speed, vector<int>& efficiency, int k) {
        vector<pair<int, int>> ess;
        for (int i = 0; i < n; ++i)
            ess.push_back({efficiency[i], speed[i]});
        sort(begin(ess), end(ess));

        long sumS = 0, res = 0;
        priority_queue <int, vector<int>, greater<int> > pq;
        for (int i = n - 1; i >= 0; --i) {
            pq.push(ess[i].second);
            sumS += ess[i].second;
            if (pq.size() > k) {
                sumS -= pq.top();
                pq.pop();
            }
            res = max(res, sumS * ess[i].first);
        }
        return res % (int)(1e9+7);
    }
```

## 857. Minimum Cost to Hire K Workers
```cpp
"1. Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group."
So for any two workers in the paid group,
we have wage[i] : wage[j] = quality[i] : quality[j]
So we have wage[i] : quality[i] = wage[j] : quality[j]
We pay wage to every worker in the group with the same ratio compared to his own quality.

"2. Every worker in the paid group must be paid at least their minimum wage expectation."
For every worker, he has an expected ratio of wage compared to his quality.
```

So to minimize the total wage, we want a small ratio.
So we sort all workers with their expected ratio, and pick up K first worker.
Now we have a minimum possible ratio for K worker and we their total quality.

As we pick up next worker with bigger ratio, we increase the ratio for whole group.
Meanwhile we remove a worker with highest quality so that we keep K workers in the group.
We calculate the current ratio * total quality = total wage for this group.

We redo the process and we can find the minimum total wage.
Because workers are sorted by ratio of wage/quality.
For every ratio, we find the minimum possible total quality of K workers.

Example:

`quality = [10,20,5], wage = [70,50,30], K = 2`
Wage/quality = 7,2.5,6
For each quality, we need to pay 7,2.5,6
For pick second and third: pay: 6*(25) = 150
For pick first and second: pay:7*(30) = 210
For pick first and third: pay: 7*15 = 105

付钱是以组内最高的wage/quality来算的，所以排序wage/quality，同时尽量使得quality小，所以用优先队列维护最小的k个quality
```cpp
double mincostToHireWorkers(vector<int> q, vector<int> w, int K) {
        vector<vector<double>> workers;
        for (int i = 0; i < q.size(); ++i)
            workers.push_back({(double)(w[i]) / q[i], (double)q[i]});
        sort(workers.begin(), workers.end());
        double res = DBL_MAX, qsum = 0;
        priority_queue<int> pq;
        for (auto worker: workers) {
            qsum += worker[1], pq.push(worker[1]);
            if (pq.size() > K) qsum -= pq.top(), pq.pop();
            if (pq.size() == K) res = min(res, qsum * worker[0]);
        }
        return res;
    }
```

## 164. Maximum Gap
时间复杂度为O(n)的排序算法有计数排序（比如一共有n种可能，创建一个O（N）的哈希表）、基数排序和桶排序，三者的基本思想差不多，某种意义上都是一种哈希算法，通过把无序数组的元素哈希到有序键值上实现排序。
#### 基数排序(Radix sort)

https://www.cnblogs.com/sun/archive/2008/06/26/1230095.html
1. 从低位到高位排序：
        如果要从高位排序, 那么次高位的排序会影响高位已经排好的大小关系. 在数学中, 数位越高,数位值对数的大小的影响就越大.从低位开始排序,就是对这种影响的排序. 数位按照影响力从低到高的顺序排序, 数位影响力相同则比较数位值.
2. 为什么同一数位的排序子程序要使用稳定排序?
        稳定排序的意思是指, 待排序相同元素之间的相对前后关系,在各次排序中不会改变.比如实例中具有十位数字5的两个数字58和356, 在十位排序之前356在58之前,在十位排序之后, 356依然在58之前.

        稳定排序能保证,上一次的排序成果被保留,十位数的排序过程能保留个位数的排序成果,百位数的排序过程能保留十位数的排序成果.
3. 只适用于正整数，字符串，浮点数，不适合负数
```py
def radix_sort(s):
    """基数排序"""
    i = 0 # 记录当前正在排拿一位，最低位为1
    max_num = max(s)  # 最大值
    j = len(str(max_num))  # 记录最大值的位数
    while i < j:
        bucket_list =[[] for _ in range(10)] #初始化桶数组
        for x in s:
            bucket_list[int(x / (10**i)) % 10].append(x) # 找到位置放入桶数组
        print(bucket_list)
        s.clear()
        for x in bucket_list:   # 放回原序列
            for y in x:
                s.append(y)
        i += 1
if __name__ == '__main__':
    a = [334,5,67,345,7,345345,99,4,23,78,45,1,3453,23424]
    radix_sort(a)
    print(a)
```


基数排序基于一个引理：对于无序数组的某一位按位排序是稳定的（不改变无序数组原来的顺序）。因此，我们可以对无序数组arr的第0位排序，得到第0位有序的数组arr0，再对arr0的第1位排序，得到第1位有序的数组arr1，由于对第1位的排序不改变第0位的顺序，因此arr1的末两位都是有序的……以此类推，我们对每一位逐次排序，就可以得到整体有序的数组。由于按位排序与进制基数（base）的选取有关，因此该排序算法称为“基数排序”。通常我们选取10为基数。

基数排序的时间复杂度为O(d(n+r))，其中其中r为基数，d是无序数组最大的元素在基数r下的位数，n是无序数组的元素个数；空间复杂度为O(r+n)，需要维护r个桶，r个桶总共放了n个元素。

除了直接用r个数组维护r个桶外，基数排序有一种空间优化，引入辅助计数器数组cnt[r]，其中cnt[i]表示当前位为i的元素个数。然后将cnt累加，从而cnt[i]表示当前位<=i的元素个数，将cnt[i]作为对应元素在新的排序过程后的下标。此时，只需维护一个长度为n的数组nums和一个长度为r的数组cnt即可，无需二维数组表示r个桶。

```py
class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        def radix_sort(arr):
            max_num = max(arr)
            max_digit = len(str(max_num))
            for i in range(max_digit):
                # init bucket arr, 10 buckets
                bucket_list = [[] for _ in range(10)]
                for num in arr:
                    # put in correct bucket, from the lower digit to higher digit
                    bucket_list[num//(10**i)%10].append(num)
                arr.clear()
                for bucket in bucket_list:
                    for num in bucket:
                        arr.append(num)
                    
        n = len(nums)
        if n < 2: return 0
        radix_sort(nums)
        res = 0
        for i in range(1,n):
            res = max(res,nums[i]-nums[i-1])
        return res
```

#### 计数排序
计数排序的基本思想是：对每一个输入的元素a[i]，确定小于 a[i] 的元素个数。所以可以直接把 a[i] 放到它输出数组中的位置上。假设有5个数小于 a[i]，所以 a[i] 应该放在数组的第6个位置上。
```py
def counting_sort(a, k):  # k = max(a)
    n = len(a)  # 计算a序列的长度
    b = [0 for i in range(n)]  # 设置输出序列并初始化为0
    c = [0 for i in range(k + 1)]  # 设置计数序列并初始化为0，
    for j in a:
        c[j] = c[j] + 1
    for i in range(1, len(c)):
        c[i] = c[i] + c[i-1]
    for j in a:
        b[c[j] - 1] = j
        c[j] = c[j] - 1
    return b
```

#### 桶排序
桶排序的基本思想是：把数组a划分为n个大小相同子区间（桶），每个子区间各自排序，最后合并。桶排序要求数据的分布必须均匀，不然可能会失效。计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。


对于本题，先求出最大最小值，然后确定桶的大小为 (max-min)/n+1,这样的话就一共有n个桶。
对于每个桶，我们记录桶内的最大值和最小值，然后对于每个数更新它的最大值和最小值.


max gap 只可能来自”相邻”的两个桶 b[i] 和 b[j], j > i, b[i] 和 b[j] 之间的桶（如果有）必须为空。因为一共只有n个数，所以不可能都在同一个桶里面，所以跨越桶之间的值才是最小值。
```cpp
class Solution {
public:
    int maximumGap(vector<int>& nums) {
        const int n = nums.size();
        if (n <= 1) return 0;
        
        const auto mm = minmax_element(nums.begin(), nums.end());
        const int range = *mm.second - *mm.first;
        const int bin_size = range / n + 1;
        vector<int> min_vals(n, INT_MAX);
        vector<int> max_vals(n, INT_MIN);
        for (const int num : nums) {
            const int index = (num - *mm.first) / bin_size;
            min_vals[index] = min(min_vals[index], num);
            max_vals[index] = max(max_vals[index], num);
        }
        
        int max_gap = 0;
        int prev_max = max_vals[0];
        for (int i = 1; i < n; ++i) {
            if (min_vals[i] != INT_MAX) {
                max_gap = max(max_gap, min_vals[i] - prev_max);
                prev_max = max_vals[i];
            }
        }
        return max_gap;
    }
};
```

## 287. Find the Duplicate Number
If we can modify array, just use the index, and set the number at that index to be negative, if we find a index is already negative and we trying to set it negative, it means there are dupilicates in the array and the index that we are tring to set to negative agian is the result.

Since we can't modify the array and must use constant space, 

#### O(N)
经过热心网友 waruzhi 的留言提醒还有一种 O(n) 的解法，并给了参考帖子，发现真是一种不错的解法，其核心思想快慢指针在之前的题目 Linked List Cycle II 中就有应用，这里应用的更加巧妙一些，由于题目限定了区间 [1,n]，所以可以巧妙的利用坐标和数值之间相互转换，而由于重复数字的存在，那么一定会形成环，用快慢指针可以找到环并确定环的起始位置，确实是太巧妙了！

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = 0, fast = 0, t = 0;
        while (true) {
            slow = nums[slow];
            fast = nums[nums[fast]];
            if (slow == fast) break;
        }
        while (true) {
            slow = nums[slow];
            t = nums[t];
            if (slow == t) break;
        }
        return slow;
    }
};
```

## 135. Candy

## 330	Patching Array
Let miss be the **smallest sum in [0,n] that we might be missing**. Meaning we already know we can build all sums in [0,miss). Then if we have a number num <= miss in the given array, we can add it to those smaller sums to build all sums in [0,miss+num).(becasue we can already build [0,miss), so add num we can build **[0,miss+num)**)

Example: Let's say the input is nums = [1, 2, 4, 13, 43] and n = 100. We need to ensure that all sums in the range [1,100] are possible.

Using the given numbers 1, 2 and 4, we can already build all sums from 0 to 7, i.e., the range [0,8). But we can't build the sum 8, and the next given number (13) is too large. So we insert 8 into the array. Then we can build all sums in [0,16).

Do we need to insert 16 into the array? No! We can already build the sum 3, and adding the given 13 gives us sum 16. We can also add the 13 to the other sums, extending our range to [0,29).

And so on. The given 43 is too large to help with sum 29, so we must insert 29 into our array. This extends our range to [0,58). But then the 43 becomes useful and expands our range to [0,101). At which point we're done.

```py
class Solution:
    def minPatches(self, nums: List[int], n: int) -> int:
        # Let miss be the smallest sum in [0,n] that we might be missing
        miss=1
        i=0
        # we can represent [0,miss), so we need miss to be at least n+1
        res = 0
        while miss <= n:
            if i < len(nums) and nums[i] <= miss:
                miss += nums[i]
                i+=1
            else:
                res += 1
                # we add miss to the patch, so we can form [0,miss+miss) now
                miss += miss
        return res
```

## 135. Candy
#### DP
```cpp
class Solution {
public:
    int min_candy(int pos,vector<int>&dp,vector<int>&ratings){
        dp[pos] = 1;
        if(pos > 0 and ratings[pos]>ratings[pos-1]){
            dp[pos] = max(dp[pos],(dp[pos-1]>0?dp[pos-1]:min_candy(pos-1,dp,ratings))+1);
        }
        if(pos<ratings.size()-1 && ratings[pos]>ratings[pos+1]){
            dp[pos] = max(dp[pos],(dp[pos+1]>0?dp[pos+1]:min_candy(pos+1,dp,ratings))+1);
        } 
        return dp[pos];
    }
    int candy(vector<int>& ratings) {
        auto n = ratings.size();
        if(n==0) return 0;
        vector<int> dp(n,0);
        auto res = 0;
        for(int i=0;i<n;i++){
            res += dp[i] > 0? dp[i]:min_candy(i,dp,ratings);
        }
        return res;
    }
};
```
#### Tricky greedy
这道题看起来很难，其实解法并没有那么复杂，当然我也是看了别人的解法才做出来的，先来看看两遍遍历的解法，首先初始化每个人一个糖果，然后这个算法需要遍历两遍，第一遍从左向右遍历，如果右边的小盆友的等级高，等加一个糖果，这样保证了一个方向上高等级的糖果多。然后再从右向左遍历一遍，如果相邻两个左边的等级高，而左边的糖果又少的话，则左边糖果数为右边糖果数加一。最后再把所有小盆友的糖果数都加起来返回即可。代码如下：
```cpp
class Solution {
public:
    int candy(vector<int>& ratings) {
        int res = 0, n = ratings.size();
        vector<int> nums(n, 1);
        for (int i = 0; i < n - 1; ++i) {
            if (ratings[i + 1] > ratings[i]) nums[i + 1] = nums[i] + 1;
        }
        for (int i = n - 1; i > 0; --i) {
            if (ratings[i - 1] > ratings[i]) nums[i - 1] = max(nums[i - 1], nums[i] + 1);
        }
        for (int num : nums) res += num;
        return res;
    }
};
```

## 23. Merge k Sorted Lists

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Node implements Comparable<Node>{
    int key;
    ListNode node;
    public Node(int key,ListNode node){
        this.key = key;
        this.node = node;
    }
    
    @Override 
    public int compareTo(Node other){
        if(this.key < other.key){
            return -1;
        }
        else if (this.key == other.key){
            return 0;
        }
        else{
            return 1;
        }
    }
}
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<Node> pq = new PriorityQueue<Node>();
        ListNode dummy = new ListNode(0);
        ListNode tmp = dummy;
        for(ListNode ln : lists){
            if(ln != null){
                pq.offer(new Node(ln.val,ln));
            }
        }
        while(!pq.isEmpty()){
            Node cur = pq.poll();
            tmp.next = new ListNode(cur.key);
            tmp = tmp.next;
            if(cur.node.next != null){
                pq.offer(new Node(cur.node.next.val,cur.node.next));
            }
        }
        return dummy.next;
    }
}
```