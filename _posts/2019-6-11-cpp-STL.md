---
layout: post
title:  "C# Indexers"
categories: CPP
---
# Common Methods
* Collection.empty() - Returns whether the set is empty.
* Collection.size() - Returns the number of elements in the set.
* Collection.begin() – Returns an iterator to the first element in the set.
* Collection.end() – Returns an iterator to the theoretical element that follows last element in the set.
* Collection.clear() – It is used to remove all the elements of the vector container
<hr>

## Vector
Implemented with Array
1. push_back() – It push the elements into a vector from the back
2. pop_back() – It is used to pop or remove elements from a vector from the back.

Accessing Front and Back: vector::front() and vector::back() in C++ STL

3. erase() – It is used to remove elements from a container from the specified position or range.
4. insert() – It inserts new elements before the element at the specified position
5. swap() – It is used to swap the contents of one vector with another vector of same type. Sizes may differ.
6. emplace() – It extends the container by inserting new element at position
7. emplace_back() – It is used to insert a new element into the vector container, the new element is added to the end of the vector
8. assign() – It assigns new value to the vector elements by replacing old ones

#### v.assign(int size, int value)
Parameters: 
* size - number of values to be assigned
* value - value to be assigned to the vectorname
Eg.  v.assign(7, 100); Assign v with 7 elements, each is 100

#### v.assign(arr, arr + size)
Parameters: 
* arr - the array which is to be assigned to a vector
* size - number of elements from the beginning which has to be assigned.

<hr>

## Stack


<hr>

## Queue


<hr>


## SET
[docs](https://www.geeksforgeeks.org/set-in-cpp-stl/)
#### Insert
insert(const g) – Adds a new element ‘g’ to the set.
```
iterator set_name.insert(element)
iterator set_name.insert(iterator position, element)
iterator set_name.insert(iterator position1, iterator position2) 
```
#### Erase
1. setname.erase(position)
2. setname.erase(startingposition, endingposition)

#### Find
find(const g) – Returns an iterator to the element ‘g’ in the set if found, else returns the iterator to end.

#### Count
set_name.count(element) 
Parameters: The function accepts one mandatory parameter element which specifies the element whose count is to be returned.

Return Value: The function returns 1 or 0 as the set contains unique elements only. It returns 1 if the value is present in the set container. It returns 0 if it is not present in the container.

<hr>

## Map
Red-Black Tree for keys. So insert and delete are all O(logN)

#### Insert
pair insert(keyvalue, mapvalue) – Adds a new element to the map
#### Erase
erase(const g)– Removes the key value ‘g’ from the map

erase(iterator position) – Removes the element at the position pointed by the iterator

#### Count
map count() function in C++ STL– Returns the number of matches to element with key value ‘g’ in the map.

#### Find
map find() function in C++ STL– Returns an iterator to the element with key value ‘g’ in the map if found, else returns the iterator to end.

Return Value: The function returns an iterator or a constant iterator which refers to the position where the key is present in the map. If the key is not present in the map container, it returns an iterator or a constant iterator which refers to map.end().

<hr>

## Unordered Map
When it comes to efficiency, there is a huge difference between maps and unordered maps.
We must know the internal working of both to decide which one is to be used.

| | map  | unordered_map |
| :--: | :--: | :--: |
| Ordering        | increasing  order(by default)   | no ordering |
| Implementation  | Self balancing BST like Red-Black Tree  | Hash Table |
| search time     | log(n)              | O(1) -> Average  O(n) -> Worst Case |
| Insertion time  | log(n) + Rebalance  | Same as search |                 
| Deletion time   | log(n) + Rebalance  | Same as search |


## Pair
This class couples together a pair of values, which may be of different types
A pair is a specific case of a std::tuple with two elements

Accessing with  **p.first** and **p.second** 

mymap.insert ( std::pair<char,int>('a',100) );

Example
```
for(auto i = 0 ; i < list2.size() ; i++ ){
    auto it = myMap.find(list2[i]);
    if(it != myMap.end()){
        if( it->second + i <= curMin){
            if (it->second + i < curMin){
                curMin = it->second + i;
                result.clear();
            }
            result.push_back(it->first);
        }
    }
}
```
