---
layout: post
title:  Python Tree2
categories: Interview
---
## 71. Binary Tree Zigzag Level Order Traversal
```py
class Solution:
    def levelOrderBottom(self, root):
        q = [root]
        res = []
        while q:
            sizeQ = len(q)
            level = []
            for i in range(sizeQ):
                cur = q.pop(0)
                if not cur: continue
                level.append(cur.val)
                q.append(cur.left)
                q.append(cur.right)
            if level:
                res += [level]
        return res[::-1]
```

## 107. Binary Tree Level Order Traversal II
```py
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        q = [root]
        res = []
        zig = True
        while q:
            sizeQ = len(q)
            level = []
            for i in range(sizeQ):
                cur = q.pop(0)
                if not cur: continue
                level.append(cur.val)
                q.append(cur.left)
                q.append(cur.right)
            if not zig:
                level.reverse()
            zig = not zig
            if level:
                res += [level]
        return res
```

## 760. Binary Tree Right Side View
```py
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        q = [root]
        res = []
        while q:
            sizeQ = len(q)
            rightest = None
            for i in range(sizeQ):
                cur = q.pop(0)
                if not cur: continue
                rightest = cur
                q.append(cur.left)
                q.append(cur.right)
            if rightest:
                res.append(rightest.val)
        return res
```

## 98. Validate Binary Search Tree
```py
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        self.res = True
        INF = 9999999999
        def helper(root,h,l):
            if not root: return
            if l >= root.val or h <= root.val:
                self.res = False
                return
            helper(root.left,root.val,l)
            helper(root.right,h,root.val)
        helper(root,INF,-INF)
        return self.res
```

## 235. Lowest Common Ancestor of a Binary Search Tree
#### Solution make use of BST
Just walk down from the whole tree's root as long as both p and q are in the same subtree (meaning their values are both smaller or both larger than root's). This walks straight from the root to the LCA, not looking at the rest of the tree, so it's pretty much as fast as it gets. Logn Time
```py
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        while (root.val-p.val) * (root.val-q.val) > 0:
            root = root.left if root.val > p.val else root.right
        return root
        
```

#### Solution same to Lowest Common Ancestor of a Binary Tree
```py
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        self.res = None
        def helper(root,p,q):
            if not root or self.res: return (False,False)
            l,r = helper(root.left,p,q),helper(root.right,p,q)
            retp,retq= l[0] or r[0] or root == p, l[1] or r[1] or root == q
            if retp and retq and self.res == None:
                self.res = root
            return (retp,retq)
        helper(root,p,q)
        return self.res
        
```

### 236. Lowest Common Ancestor of a Binary Tree
```py
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        self.res = None
        def helper(root,p,q):
            if not root or self.res: return (False,False)
            l,r = helper(root.left,p,q),helper(root.right,p,q)
            retp,retq= l[0] or r[0] or root == p, l[1] or r[1] or root == q
            if retp and retq and self.res == None:
                self.res = root
            return (retp,retq)
        helper(root,p,q)
        return self.res
```


## 108. Convert Sorted Array to Binary Search Tree
```
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def helper(nums,l,r):
            if l > r : return None
            mid = (l+r)//2
            root = TreeNode(nums[mid])
            root.left = helper(nums,l,mid-1)
            root.right = helper(nums,mid+1,r)
            return root
        return helper(nums,0,len(nums)-1)
```

## 109. Convert Sorted List to Binary Search Tree
转化为数组，O(N)时间O(N)额外空间，和108一样

另一种办法是找到链表的中点（也就是根节点），然后分而治之，找到链表的中点就用快慢指针即可

```py
class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        if not head: return None
        if not head.next: return TreeNode(head.val)
        slow,fast,pre = head,head,None
        while fast and fast.next:
            pre = slow
            slow = slow.next
            fast = fast.next.next
        pre.next = None
        root = TreeNode(slow.val)
        root.left = self.sortedListToBST(head)
        root.right = self.sortedListToBST(slow.next)
        return root
```

## 173. Binary Search Tree Iterator
#### Recursion inorder
```py
class BSTIterator:
    def __init__(self, root: TreeNode):
        def traverse(r):
            if not r: return
            traverse(r.left)
            self.inorder.append(r.val)
            traverse(r.right)
        self.root = root
        self.inorder = []
        traverse(root)
        
    def next(self) -> int:
        return self.inorder.pop(0)
        
    def hasNext(self) -> bool:
        return len(self.inorder)>0 
```

#### Iterator
```py
class BSTIterator(object):
    def __init__(self, root):
        """
        :type root: TreeNode
        """
        self.current_node=root
        self.stack=[]

    def hasNext(self):
        """
        :rtype: bool
        """
        return self.current_node is not None or len(self.stack)!=0

    def next(self):
        """
        :rtype: int
        """
        while self.current_node:
            self.stack.append(self.current_node)
            self.current_node=self.current_node.left
        next=self.stack.pop()
        self.current_node=next.right
        return next.val
```

## 297. Serialize and Deserialize Binary Tree
https://leetcode.com/problems/serialize-and-deserialize-binary-tree/
## 448. Inorder Successor in BST
Idea is: 
1. find p first, in the mean time, push the path into stack(**only the path where we goes left, because if we goes right, then we don't need to go back to find the successor(because inorder successor is only appeared in the other subtree**))(注意只push往左走的path，因为往右走的话，说明succssor在另一颗子树或者这个节点的父节点里面，绝对不可能是这一节点。）
2. if it has left child, goes to left. 
3. if it has a parent and it is not the right child of the parent, then parent is the answer
4. otherwise goes up, if no other ancestors exist, then it is the rightest node 
```py
class Solution:
    def inorderSuccessor(self, root, p):
        if not p or not root: return None
        stack = []
        tmp = root
        while tmp and tmp != p:
            if p.val > tmp.val: tmp = tmp.right
            else: 
                stack.append(tmp)
                tmp=tmp.left
        # if p has right child
        if tmp.right:
            tmp = tmp.right
            while tmp.left: tmp = tmp.left
            return tmp
        # goes up, if p == cur.right, means still needs to go up
        while stack:
            cur = stack.pop()
            if cur: return cur
        return None
```
https://www.lintcode.com/problem/inorder-successor-in-bst/description
## 900. Closest Binary Search Tree Value
https://www.lintcode.com/problem/closest-binary-search-tree-value/description
## 901. Closest Binary Search Tree Value II
https://www.lintcode.com/problem/closest-binary-search-tree-value-ii/description