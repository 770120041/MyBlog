---
layout: post
title:  Python Contest
categories: Interview
---
## 1371. Find the Longest Substring Containing Vowels in Even Counts
https://zxi.mytechroad.com/blog/hashtable/leetcode-1371-find-the-longest-substring-containing-vowels-in-even-counts/
https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/534135/C%2B%2BJava-with-picture
```py
class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        # from left to right, record index of the vowels
        d = { 0 : -1}
        vowels = "aeiou"
        res = 0
        state = 0
        for i,c in enumerate(s):
            j = vowels.find(c)
            if j >= 0:
                state ^= 1 << j 
            if state not in d:
                d[state] = i
            res = max(res, i-d[state])
        return res
```

## 525. Contiguous Array
Using hash map to record the state, if we meet the same state again, means we can find it. The length is `i-(d[counter]+1)+1 = i - d[counter]`
```py
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        d = {0:-1}
        counter = 0
        res = 0
        for i in range(len(nums)):
            if nums[i] == 0:
                counter += 1
            elif nums[i] == 1:
                counter -= 1
            if counter not in d:
                d[counter] = i
            # print(counter,d)
            res = max(res,i-d[counter])
        return res
```

## 1368. Minimum Cost to Make at Least One Valid Path in a Grid
Weekly Contest 179

1. 用adj list来存储树
2. 注意每个child要取最大值
Using array to store graph. And use DFS after wards
```py
class Solution:
    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:
        def dfs(nodeID, children):
            child_time = 0
            for c in child[nodeID]:
                child_time = max(child_time,dfs(c,children))
            return child_time+informTime[nodeID]
            
        child = [[] for i in range(n)]
        for i in range(n):
            if manager[i] != -1:
                child[manager[i]].append(i)
        return dfs(headID,child)
```

## 1377. Frog Position After T Seconds
同样用adjlist来存储树，但不同的地方是给的tree是undirected edges，所以其实不知道哪个是朝着顶点方向的，所以我们可以在adj list里面存储两条边，然后用一个visited 的 hash来保存visit过的点，这样从头开始遍历就可以了。

## 1367. Linked List in Binary Tree
1367. Linked List in Binary Tree

KMP or recursive

## 1366. Rank Teams by Votes
简化问题
```py
class Solution(object):
    def rankTeams(self, votes):
        """
        :type votes: List[str]
        :rtype: str
        """
        # for each team, we have an array of size n
        # so we record the index if appearance of team i
        # for ["ABC","ACB","ABC","ACB","ACB"]
        # we have [0,0,0,0,0] for A, [1,2,1,2,2] for B and [2,1,2,1,1] for C
        # so we can record as [5,0,0,0,0] [0,2,3,0,0] [0,3,2,0,0], sort by decreasing order we get the result.
        def compare(a,b):
            l1,l2 = a[1],b[1]
            for i in range(len(l1)):
                if l1[i] > l2[i]:
                    return 1
                elif l1[i] < l2[i]:
                    return -1
            if a[0] < b[0]: return 1
            return -1
                    
        d = {}
        for vote in votes:
            for i in range(len(vote)):
                if vote[i] not in d: d[vote[i]] = [0 for j in range(26)]
                d[vote[i]][i] += 1
        res = []
        for k,v in sorted(d.items(),cmp = compare, reverse = True):
            res.append(k)
        return "".join(res)
        
```