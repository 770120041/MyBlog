---
layout: post
title:  Python Contest
categories: Interview
---
## 1371. Find the Longest Substring Containing Vowels in Even Counts
https://zxi.mytechroad.com/blog/hashtable/leetcode-1371-find-the-longest-substring-containing-vowels-in-even-counts/
https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/534135/C%2B%2BJava-with-picture
```py
class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        # from left to right, record index of the vowels
        d = { 0 : -1}
        vowels = "aeiou"
        res = 0
        state = 0
        for i,c in enumerate(s):
            j = vowels.find(c)
            if j >= 0:
                state ^= 1 << j 
            if state not in d:
                d[state] = i
            res = max(res, i-d[state])
        return res
```

## 525. Contiguous Array
Using hash map to record the state, if we meet the same state again, means we can find it. The length is `i-(d[counter]+1)+1 = i - d[counter]`
```py
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        d = {0:-1}
        counter = 0
        res = 0
        for i in range(len(nums)):
            if nums[i] == 0:
                counter += 1
            elif nums[i] == 1:
                counter -= 1
            if counter not in d:
                d[counter] = i
            # print(counter,d)
            res = max(res,i-d[counter])
        return res
```

## 1368. Minimum Cost to Make at Least One Valid Path in a Grid
Weekly Contest 179

1. 用adj list来存储树
2. 注意每个child要取最大值
Using array to store graph. And use DFS after wards
```py
class Solution:
    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:
        def dfs(nodeID, children):
            child_time = 0
            for c in child[nodeID]:
                child_time = max(child_time,dfs(c,children))
            return child_time+informTime[nodeID]
            
        child = [[] for i in range(n)]
        for i in range(n):
            if manager[i] != -1:
                child[manager[i]].append(i)
        return dfs(headID,child)
```

## 1377. Frog Position After T Seconds
同样用adjlist来存储树，但不同的地方是给的tree是undirected edges，所以其实不知道哪个是朝着顶点方向的，所以我们可以在adj list里面存储两条边，然后用一个visited 的 hash来保存visit过的点，这样从头开始遍历就可以了。

## 1367. Linked List in Binary Tree
1367. Linked List in Binary Tree

KMP or recursive

## 1366. Rank Teams by Votes
简化问题
```py
class Solution(object):
    def rankTeams(self, votes):
        """
        :type votes: List[str]
        :rtype: str
        """
        # for each team, we have an array of size n
        # so we record the index if appearance of team i
        # for ["ABC","ACB","ABC","ACB","ACB"]
        # we have [0,0,0,0,0] for A, [1,2,1,2,2] for B and [2,1,2,1,1] for C
        # so we can record as [5,0,0,0,0] [0,2,3,0,0] [0,3,2,0,0], sort by decreasing order we get the result.
        def compare(a,b):
            l1,l2 = a[1],b[1]
            for i in range(len(l1)):
                if l1[i] > l2[i]:
                    return 1
                elif l1[i] < l2[i]:
                    return -1
            if a[0] < b[0]: return 1
            return -1
                    
        d = {}
        for vote in votes:
            for i in range(len(vote)):
                if vote[i] not in d: d[vote[i]] = [0 for j in range(26)]
                d[vote[i]][i] += 1
        res = []
        for k,v in sorted(d.items(),cmp = compare, reverse = True):
            res.append(k)
        return "".join(res)
        
```

## Cinema Seat Allocation
From Biweekly Contest 22

Bit op, for accelerate
```py
class Solution:
    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:
        # reservered seats can be sorted, or stored
        # better to store in hash map
        d = {}
        for seat in reservedSeats:
            # 0 available, 1 occupied
            # maskby and with 1, if have any 0, then can't allocate
            if seat[0] not in d: d[seat[0]] =0b0000000000
            d[seat[0]] |= 1 << (10-seat[1])   
        res = 0
        total_mask = 0b0111111110
        left_mask = 0b0111100000
        right_mask = 0b0000011110
        mid_mask = 0b0001111000
        for v in d.values():
            if v & total_mask == 0:
                res += 2
            elif v & left_mask == 0:
                res += 1
            elif v & right_mask == 0:
                res += 1
            elif v & mid_mask == 0: 
                res += 1
        return res + 2*(n-len(d))
```

## 1388. Pizza With 3n Slices
很像 213. House Robber II，但这里注意不是严格的in a row, 比如`1,2,3,4,5,6`,我们不能取2，4，6，因为取了2以后剩下4，5，6，再取4以后5，6就没有了。

1. 这个问题可以转化为，从长度为 n 的环形数组中选择 n/3 个互不相邻的数字。
2. 我们分为两类，一类是不允许取第一个数字，一类是不允许去最后一个数字。
3. 对这两类问题分别做动态规划，此时转换为线性数组上的问题。
4. 下标从 0 开始。设状态 f(i,j) 表示前 i 个数字，取了 j 个数字的最大总和。
5. 转移时，可以取第 i 个数字，也可以不取第 i 个数字，很容易写出转移方程。
6. 最终答案为 f(n−1,n/3)。
```cpp
class Solution {
public:
    int solve(const vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> f(n, vector<int>(n / 3 + 1, INT_MIN));

        f[0][0] = 0;
        f[0][1] = nums[0];
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= n / 3; j++) {
                // not take num[i]
                f[i][j] = f[i - 1][j];
                // why need this?
                if (j == 1) f[i][1] = max(f[i][1], nums[i]);
                // take current number
                if (i >= 2 && j >= 1) f[i][j] = max(f[i][j], f[i - 2][j - 1] + nums[i]);
            }
        }

        return f[n - 1][n / 3];
    }

    int maxSizeSlices(vector<int>& slices) {
        vector<int> nums(slices);
        // create nums array for remove the last element and last element
        nums[0] = slices.back() = INT_MIN;
        return max(solve(slices), solve(nums));
    }
};
```

## 1392. Longest Happy Prefix
#### Py start with
```py
class Solution:
    def longestPrefix(self, s: str) -> str:
        for i in range(1, len(s)):
            if s.startswith(s[i:]):
                return s[i:]
        return ""
```
#### Rolling hash
https://blog.csdn.net/yanghua_kobe/article/details/8914970

The problem for this is, when we are rolling a b c d a b c d, in front we meet abcdabcd, in rear we meat dcbadcba, so we need to make sure that the hash of them is same

To deal with this, **for calculation of suffixHash, we are adding a character at the most significant bit. Whereas for prefix hash, we are adding a character at the least significant bit.**

```java
class Solution {
    long mod = 1_000_000_007;
    
    public String longestPrefix(String s) {
        int n = s.length();
        int low = 0;
        int high = n-1;
        
        long prefixHash = 0;
        long suffixHash = 0;        
        //x is used to maintain powers of 26.
        long x = 1;
        
        int res_high = 0;
        while(low<n-1 && high>=0) {
            int c = s.charAt(low) - 'a';
            prefixHash = (prefixHash*26 + c)%mod;
            
            c = s.charAt(high) - 'a';
            suffixHash = (suffixHash + x*c)%mod;
            x=(x*26)%mod;
            
            if(prefixHash==suffixHash) {
                res_high = low+1;
            }
            ++low;
            --high;
        }       
        String res = s.substring(0, res_high);
        return res;
    }
}
```

## 1354. Construct Target Array With Multiple Sums



Explanation
```
The total sum always bigger than all elements.
We can decompose the biggest number.
Each round we get the current maximum value,
delete it by the sum of other elements.

Time O(N) to build up the priority queue.
Time O(logMaxAlogN)) for the reducing value part.
We have O(maxA) loops, which is similar to gcd
Space O(N)

% operation is totally much more important than using heap.
If brute force solution is accepted,
then the solutions without % are right and good.

But the truth is that, solution without % should be TLE.
So I afraid that, without % is wrong to me.
```

Why use %

```cpp
a1+a2+a3+mx = total

how to find a0(what is originally at index of mx?

a1+a2+a3+a0 -> a1+a2+a3+a4(a4 = a1+a2+a3+a0) -> a1+a2+a3+a5(a5=a4+a1+a2+a3 = 2*(a1+a2+a3+a4)+a0)... -> mx
so mx = k*(a1+a2+a3) + a0
so a0 = mx%(total-mx)

By keep on back trakcing, we can find the result
```

Java
O(nlogn) to build up the priority queue.
```java
    public boolean isPossible(int[] A) {
        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a, b) -> (b - a));
        long total = 0;
        for (int a : A) {
            total += a;
            pq.add(a);
        }
        while (true) {
            int a = pq.poll();
            total -= a;
            if (a == 1 || total == 1)
                return true;
            if (a < total || total == 0 || a % total == 0)
                return false;
            a %= total;
            total += a;
            pq.add(a);
        }
    }
```
C++
```cpp
    bool isPossible(vector<int>& A) {
        long total = 0;
        int n = A.size(), a;
        priority_queue<int> pq(A.begin(), A.end());
        for (int a : A)
            total += a;
        while (true) {
            a = pq.top(); pq.pop();
            total -= a;
            if (a == 1 || total == 1)
                return true;
            if (a < total || total == 0 || a % total == 0)
                return false;
            a %= total;
            total += a;
            pq.push(a);
        }
    }
```
Python
```py
    def isPossible(self, A):
        total = sum(A)
        A = [-a for a in A]
        heapq.heapify(A)
        while True:
            a = -heapq.heappop(A)
            total -= a
            if a == 1 or total == 1: return True
            if a < total or total == 0 or a % total == 0:
                return False
            a %= total
            total += a
            heapq.heappush(A, -a)
            
```


# Weekly 174
## 1340. Jump Game V
#### DP TLE
Memo DP
O(n*d)
```py
class Solution(object):
    def maxJumps(self, arr, d):
        """
        :type arr: List[int]
        :type d: int
        :rtype: int
        """
        # memo DP O(N*D)
        def visit(arr,dp,i,n,d):
            if dp[i]: return dp[i]
            dp[i] = 1
            for k in range(i+1,i+d+1):
                if k < 0 or k >= n or arr[k]>= arr[i]: break
                dp[i] = max(dp[i],visit(arr,dp,k,n,d)+1)
            for k in range(i-1,i-d-1,-1):
                if k < 0 or k >= n or arr[k]>= arr[i]: break
                dp[i] = max(dp[i],visit(arr,dp,k,n,d)+1)
            return dp[i]
        n = len(arr)
        dp = [0 for i in range(n)]
        # print(dp)
        for i in range(n):
            visit(arr,dp,i,n,d)
        return max(dp)
```

# Weekly 173
## 1332. Remove Palindromic Subsequences
1.子数组(subarray)：需要在原数组中索引连续。
2.子序列(subsquence)：不需要在原数组索引连续。

所以如果是palindrome，1步，如果是空的，0步，否则2步（先除掉所有a，然后所有b）

如果是subarray的话就是一道比较麻烦的dp了
```py
class Solution(object):
    def removePalindromeSub(self, s):
        if not s: return 0
        if s == s[::-1]: return 1
        return 2
## 1345. Jump Game IV
Biweekly Contest 19
#### BFS(TLE)
```py
class Solution:
    def minJumps(self, arr: List[int]) -> int:
        # BFS
        if not arr: return 0
        n = len(arr)
        INF = len(arr)
        dp = [INF for i in range(n)]
        pos = {}
        for i in range(n):
            if arr[i] not in pos: pos[arr[i]] = []
            pos[arr[i]].append(i)
        visited = [False for i in range(n)]
        # print(pos)
        # starts from first pos
        q = [0]
        visited[0] = True
        dp[0] = 0
        while q:
            sz_q = len(q)
            for i in range(sz_q):
                cur = q.pop(0)
                neighbors = pos[arr[cur]] + [cur-1,cur+1]
                # print(cur,neighbors)
                for neighbor in neighbors:
                    if cur == neighbor or neighbor < 0 or neighbor >= n or visited[neighbor] == True:
                        continue
                    visited[neighbor] = True
                    dp[neighbor] = dp[cur] + 1
                    q.append(neighbor)        
        # print(dp)
        return dp[n-1]
```

## Compress + BFS
Compress trick: It should be repeated at least twice to remove redundent elements. because any same element can jump if they are adjacent.
```
class Solution:
    def minJumps(self, arr: List[int]) -> int:
        if not arr: return 0
        n = len(arr)
        INF = len(arr)
        # compress the array
        index = 0
        for i in range(n):
            if i > 1 and arr[i] == arr[i-1] and arr[i] == arr[i-2]: continue
            arr[index] = arr[i]
            index += 1
        arr = arr[:index]
        n = len(arr)
        dp = [INF for i in range(n)]
        pos = {}
        for i in range(n):
            if arr[i] not in pos: pos[arr[i]] = []
            pos[arr[i]].append(i)
        visited = [False for i in range(n)]
        # print(pos)
        # starts from first pos
        q = [0]
        visited[0] = True
        dp[0] = 0
        while q:
            sz_q = len(q)
            for i in range(sz_q):
                if visited[n-1]: return dp[n-1]
                cur = q.pop(0)
                neighbors = pos[arr[cur]] + [cur-1,cur+1]
                # print(cur,neighbors)
                for neighbor in neighbors:
                    if cur == neighbor or neighbor < 0 or neighbor >= n or visited[neighbor] == True:
                        continue
                    visited[neighbor] = True
                    dp[neighbor] = dp[cur] + 1
                    q.append(neighbor)        
        # print(dp)
        return dp[n-1]
```