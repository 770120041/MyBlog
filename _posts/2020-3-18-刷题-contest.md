---
layout: post
title:  Python Contest
categories: Interview
---
## 1371. Find the Longest Substring Containing Vowels in Even Counts
https://zxi.mytechroad.com/blog/hashtable/leetcode-1371-find-the-longest-substring-containing-vowels-in-even-counts/
https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/534135/C%2B%2BJava-with-picture
```py
class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        # from left to right, record index of the vowels
        d = { 0 : -1}
        vowels = "aeiou"
        res = 0
        state = 0
        for i,c in enumerate(s):
            j = vowels.find(c)
            if j >= 0:
                state ^= 1 << j 
            if state not in d:
                d[state] = i
            res = max(res, i-d[state])
        return res
```

## 525. Contiguous Array
Using hash map to record the state, if we meet the same state again, means we can find it. The length is `i-(d[counter]+1)+1 = i - d[counter]`
```py
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        d = {0:-1}
        counter = 0
        res = 0
        for i in range(len(nums)):
            if nums[i] == 0:
                counter += 1
            elif nums[i] == 1:
                counter -= 1
            if counter not in d:
                d[counter] = i
            # print(counter,d)
            res = max(res,i-d[counter])
        return res
```

## 1368. Minimum Cost to Make at Least One Valid Path in a Grid
Weekly Contest 179

1. 用adj list来存储树
2. 注意每个child要取最大值
Using array to store graph. And use DFS after wards
```py
class Solution:
    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:
        def dfs(nodeID, children):
            child_time = 0
            for c in child[nodeID]:
                child_time = max(child_time,dfs(c,children))
            return child_time+informTime[nodeID]
            
        child = [[] for i in range(n)]
        for i in range(n):
            if manager[i] != -1:
                child[manager[i]].append(i)
        return dfs(headID,child)
```

## 1377. Frog Position After T Seconds
同样用adjlist来存储树，但不同的地方是给的tree是undirected edges，所以其实不知道哪个是朝着顶点方向的，所以我们可以在adj list里面存储两条边，然后用一个visited 的 hash来保存visit过的点，这样从头开始遍历就可以了。

## 1367. Linked List in Binary Tree
1367. Linked List in Binary Tree

KMP or recursive

## 1366. Rank Teams by Votes
简化问题
```py
class Solution(object):
    def rankTeams(self, votes):
        """
        :type votes: List[str]
        :rtype: str
        """
        # for each team, we have an array of size n
        # so we record the index if appearance of team i
        # for ["ABC","ACB","ABC","ACB","ACB"]
        # we have [0,0,0,0,0] for A, [1,2,1,2,2] for B and [2,1,2,1,1] for C
        # so we can record as [5,0,0,0,0] [0,2,3,0,0] [0,3,2,0,0], sort by decreasing order we get the result.
        def compare(a,b):
            l1,l2 = a[1],b[1]
            for i in range(len(l1)):
                if l1[i] > l2[i]:
                    return 1
                elif l1[i] < l2[i]:
                    return -1
            if a[0] < b[0]: return 1
            return -1
                    
        d = {}
        for vote in votes:
            for i in range(len(vote)):
                if vote[i] not in d: d[vote[i]] = [0 for j in range(26)]
                d[vote[i]][i] += 1
        res = []
        for k,v in sorted(d.items(),cmp = compare, reverse = True):
            res.append(k)
        return "".join(res)
        
```

## 1345. Jump Game IV
Biweekly Contest 19
#### BFS(TLE)
```py
class Solution:
    def minJumps(self, arr: List[int]) -> int:
        # BFS
        if not arr: return 0
        n = len(arr)
        INF = len(arr)
        dp = [INF for i in range(n)]
        pos = {}
        for i in range(n):
            if arr[i] not in pos: pos[arr[i]] = []
            pos[arr[i]].append(i)
        visited = [False for i in range(n)]
        # print(pos)
        # starts from first pos
        q = [0]
        visited[0] = True
        dp[0] = 0
        while q:
            sz_q = len(q)
            for i in range(sz_q):
                cur = q.pop(0)
                neighbors = pos[arr[cur]] + [cur-1,cur+1]
                # print(cur,neighbors)
                for neighbor in neighbors:
                    if cur == neighbor or neighbor < 0 or neighbor >= n or visited[neighbor] == True:
                        continue
                    visited[neighbor] = True
                    dp[neighbor] = dp[cur] + 1
                    q.append(neighbor)        
        # print(dp)
        return dp[n-1]
```

## Compress + BFS
Compress trick: It should be repeated at least twice to remove redundent elements. because any same element can jump if they are adjacent.
```
class Solution:
    def minJumps(self, arr: List[int]) -> int:
        if not arr: return 0
        n = len(arr)
        INF = len(arr)
        # compress the array
        index = 0
        for i in range(n):
            if i > 1 and arr[i] == arr[i-1] and arr[i] == arr[i-2]: continue
            arr[index] = arr[i]
            index += 1
        arr = arr[:index]
        n = len(arr)
        dp = [INF for i in range(n)]
        pos = {}
        for i in range(n):
            if arr[i] not in pos: pos[arr[i]] = []
            pos[arr[i]].append(i)
        visited = [False for i in range(n)]
        # print(pos)
        # starts from first pos
        q = [0]
        visited[0] = True
        dp[0] = 0
        while q:
            sz_q = len(q)
            for i in range(sz_q):
                if visited[n-1]: return dp[n-1]
                cur = q.pop(0)
                neighbors = pos[arr[cur]] + [cur-1,cur+1]
                # print(cur,neighbors)
                for neighbor in neighbors:
                    if cur == neighbor or neighbor < 0 or neighbor >= n or visited[neighbor] == True:
                        continue
                    visited[neighbor] = True
                    dp[neighbor] = dp[cur] + 1
                    q.append(neighbor)        
        # print(dp)
        return dp[n-1]
```

## 1360. Number of Days Between Two Dates
比较好的方法是找同一个参照物
```py
class Solution:
    def daysBetweenDates(self, date1: str, date2: str) -> int:
        def isLeap(year):
            if (year % 4 == 0 and year % 100 != 0 ) or year % 400 == 0:
                return True
            return False

        def calculate(date):
            m_day = [31,28,31,30,31,30,31,31,30,31,30,31]
            year = int(date[0:4])
            month = int(date[5:7])
            day = int(date[8:10])
            res = 0
            for y in range(1971,year):
                res += 366 if isLeap(y) else 365
            for m in range(1,month):
                if month > 2 and m == 2:
                    if isLeap(year): res += 29
                    else: res += 28
                else:
                    res += m_day[m-1]
            res += day
            # print(res)
            return res
        
        return abs(calculate(date2)-calculate(date1))
```