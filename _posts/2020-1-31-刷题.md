---
layout: post
title:  Python 二分
categories: Interview
---

## General Template
If target is in nums, then if will be in one of the two. When while loops ends, then `l==r+1`
```py
class BinarySearch(self,nums:List[int],target:int) -> int:
    l,r = 0,len(nums)-1
    
    while l+1 < r:
        mid = (l+r)//2
        if nums[mid] < target:
            l = mid
        else:
            r = mid
    if(nums[l] == target):
        return nums[l]
    else:
        return nums[r] 
```

For duplicate array, find the first postion target appears. To find the first location, we can shrinking the right when `nums[mid]==target`.
```py
class BinarySearch(self,nums:List[int],target:int) -> int:
    l,r = 0,len(nums)-1
    while l+1 < r:
        mid = (l+r)//2
        if nums[mid] == target:
            r = mid
        elif nums[mid] > target:
            right = mid-1
        else:
            left = mid+1
        if nums[l] == target: return r
        if nums[r] == target: return l
        return -1
```
For duplicate array, find the last postion target appears.
```py
class BinarySearch(self,nums:List[int],target:int) -> int:
    l,r = 0,len(nums)-1
    while l+1 < r:
        mid = (l+r)//2
        if nums[mid] == target:
            l = mid
        elif nums[mid] > target:
            right = mid-1
        else:
            left = mid+1
        if nums[r] == target: return r
        if nums[l] == target: return l
        return -1
```

####  How to find the proper place to insert into an array?
The first number smaller than k: shrinking the right side, `if nums[mid]>target, right = mid-1`,so we can find the first number smaller than k

The first number larger than k: shrinking the left side, `if nums[mid]<target,left=mid+1`

## 278. First Bad Version
```py
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l,r = 0,len(nums)-1
        while l <= r:
            mid = (l+r)//2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                r = mid-1
            else:
                l = mid+1
        return l
```

## 35. Search Insert Position
```
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l,r = 0,len(nums)-1
        # first number equals target
        while l+1 < r:
            mid = (l+r)//2
            if nums[mid] == target:
                r = mid
            elif nums[mid] > target:
                r = mid-1
            else:
                l = mid
        if nums[l] >= target:
            return l
        if nums[r] < target:
            return r+1
        return r
                
```

## 33. Search in Rotated Sorted Array
https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14435/Clever-idea-making-it-simple
#### Explanation

Let's say nums looks like this: [12, 13, 14, 15, 16, 17, 18, 19, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]

Because it's not fully sorted, we can't do normal binary search. But here comes the trick:

If target is let's say 14, then we adjust nums to this, where "inf" means infinity:
[12, 13, 14, 15, 16, 17, 18, 19, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf]

If target is let's say 7, then we adjust nums to this:
[-inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]

And then we can simply do ordinary binary search.

Of course we don't actually adjust the whole array but instead adjust only on the fly only the elements we look at. And the adjustment is done by comparing both the target and the actual element against nums[0].

https://leetcode.com/problems/search-in-rotated-sorted-array/    


```cpp
int search(vector<int>& nums, int target) {
    int lo = 0, hi = nums.size();
    while (lo < hi) {
        int mid = (lo + hi) / 2;
        
        double num = (nums[mid] < nums[0]) == (target < nums[0])
                   ? nums[mid]
                   : target < nums[0] ? -INFINITY : INFINITY;
                   
        if (num < target)
            lo = mid + 1;
        else if (num > target)
            hi = mid;
        else
            return mid;
    }
    return -1;
}
```

if target < nums[0] and nums[mid] < nums[0], then they both in the right side, so we can compare target with nums[mid]
if target >= nums[0] and nums[mid] >= nums[0], then both in the left side, still compares nums[mid]
if target < nums[0] and nums[mid] > nums[0], then target in right side and nums[mid] in left side, then nums[mid] is actully -inf
if target >= nums[0] and nums[mid] < nums[0], then target in left side and nums[mid] in right side, then nums[mid] is actually +inf

```py
the core is that target is >=.
 if (target>=nums[0]) == (nums[mid]>=nums[0]):
        num = mid
    else:
        if target >= nums[0]:
            num = inf
        else:
            num = -inf
```
注意target >= nums[0], 如果target>nums[0]检测不到最左边的数字
```py
class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        if not nums:
            return -1
        INFINITY  = 999999999
        l,r = 0,len(nums)-1
        while l+1 < r:
            mid = (l+r)//2
            if (target>=nums[0]) == (nums[mid]>=nums[0]):
                num = nums[mid]
            else:
                # target in left side, then num is in right side
                if target >= nums[0]:
                    num = INFINITY
                # if target < nums[0], then target in right side, nums shall be in left side
                else:
                    num = -INFINITY
            # print(l,r,mid,num)
            if num < target:
                l = mid
            else:
                r = mid
        if nums[l] == target:
            return l
        if nums[r] == target:
            return r
        return -1
```


## 81. Search in Rotated Sorted Array II
The method for 33. Search in Rotated Sorted Array can't be used since for test cases `[1,3,1,1,1,1] 3`, the 3 can't be find easily for any ways. So we need to remove the duplicate in some way. So it can be as bad as O(N) time complexity(worst case)

So brute force will also pass
```     
def search(self, nums: List[int], target: int) -> bool:
        if not nums:
            return False
        if target in nums:
            return True
        return False
```

```
class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        if not nums:
            return False
        l,r = 0,len(nums)-1
        while l+1 < r:
            mid = (l+r)//2
            if nums[mid] == target:
                return True
            while l<mid and nums[l] == nums[mid]:
                l += 1
            # left in order
            if nums[l] <= nums[mid]:
                if nums[l] <= target < nums[mid]:
                    r = mid
                else:
                    l = mid
            else:
                if nums[mid] < target <= nums[r]:
                    l = mid
                else:
                    r = mid
        if target in {nums[l],nums[r]}:
            return True
        return False
```

## 153. Find Minimum in Rotated Sorted Array
```py
class Solution(object):
    def findMin(self, nums):
        l,r = 0,len(nums)-1
        while l+1 < r:
            mid = (l+r)//2
            # print(l,r,mid)
            if nums[mid]<=nums[r]:
                r = mid
            else:
                l = mid
        return min(nums[l],nums[r])
```

## 154. Find Minimum in Rotated Sorted Array II
```py
class Solution(object):
    def findMin(self, nums):
        l,r = 0,len(nums)-1
        while l < r and nums[l] == nums[r]:
            l += 1
        while l+1 < r:
            mid = (l+r)//2
            while l < mid and nums[l] == nums[mid]:
                l += 1
            if nums[mid]<= nums[r]:
                r = mid
            else:
                l = mid
        return min(nums[l],nums[r])
```

## 374. Guess Number Higher or Lower
```py

class Solution:
    def guessNumber(self, n: int) -> int:
        l,r = 1,n
        while l+1<r:
            mid = (l+r)//2
            g = guess(mid)
            # print(l,r,mid,g)
            if g == 0:
                return mid
            if g > 0:
                l = mid
            else:
                r = mid
        if guess(l) == 0:
            return l
        return r
```

## 162. Find Peak Element

```py
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        INF = 9999999999999
        nums = [-INF] + nums + [-INF]
        l,r = 1,len(nums)-2
        while l +1 < r:
            mid = (l+r)//2
            # print(l,r,mid)
            if nums[mid-1]<nums[mid] and nums[mid+1]<nums[mid]:
                return mid-1
            if nums[mid] > nums[mid-1]:
                l = mid
            else:
                r = mid
        if nums[l] > nums[l+1] and nums[l] > nums[l-1]:
            return l-1 
        return r-1
```