---
layout: post
title:  OS
categories: Interview
---
# Virtualization
Program execution flow:
CPU fetches information from memory -> decode -> execute

The reason why virtualization is to make the system easier to use, OS can virtualize the hardware resources.

## Process
Process is an abstraction of a **running program** created by the OS. The program itself is a bunch of instructions(and maybe some static data), waiting to spring into action. It is the operating system that gets them running.

To understand what constitutes a process, we thus have to understand its machine state: what a program can read or update when it is running. At any given time, what parts of the machine are important to the execution of this program? One obvious component of machine state that comprises a process is its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the process can address (called its address space) is part of the process.

Also part of the processâ€™s machine state are registers; many instructions explicitly read or update registers and thus clearly they are important to the execution of the process.

So process is the resource allocation unit that the OS abstracts so that we can run multiple programs in a same machine easier. The OS using **time sharing** to make many processes to virtualize the CPU resources.

![result](https://github.com/770120041/myblog/blob/master/images/2019-4/MemoryAndCode.png?raw=true)

### Creation of process
1. Load code and static data(initialized values) into memory
2. Allocate memory for the run-time stack and some space for the heap of the program
(As you should likely already know, C programs use the stack for local variables, function parameters, and return addresses; the OS allocates this memory and gives it to the process.)

a process has different states: running, ready and blocked

### PCB
A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process control block (PCB), which is really just a structure that contains
information about a specific process.

### APIS
1. fork() creates a new process by duplicating the calling process.  The
        new process is referred to as the child process.  The calling process
        is referred to as the parent process.

2. wait() can help to make this determinestic
```c
int main(int argc, char *argv[]) {
    printf("hello world (pid:%d)\n", (int) getpid());
    int rc = fork();
    if (rc < 0) { // fork failed; exit
        fprintf(stderr, "fork failed\n");
        exit(1);
    } else if (rc == 0) { // child (new process)
        printf("hello, I am child (pid:%d)\n", (int) getpid());
    } else { // parent goes down this path (main)
        int rc_wait = wait(NULL);
        printf("hello, I am parent of %d (rc_wait:%d) (pid:%d)\n",
         rc, rc_wait, (int) getpid());
    }
    return 0;
    }
```
3. exec()
In computing, exec is a functionality of an operating system that runs an executable file in the context of an already existing process, replacing the previous executable. This act is also referred to as an overlay. It is especially important in Unix-like systems, although other operating systems implement it as well. Since a new process is not created, the original process identifier (PID) does not change, but the machine code, data, heap, and stack of the process are replaced by those of the new program.

The reason why using this is easier to implement shell.

4. Sending signals to a process
like Kill, Ctri-C, Ctrl-Z signal() system call

### How to time-sharing the CPU with control
Limited-Direct-Execution

Direct execution has the obvious advantage of being fast; the program runs natively on the hardware CPU and thus executes as quickly as one would expect. 

1. How program run restricted operations?
the approach we take is to introduce a new processor mode, known as **user mode**; code that runs in user mode is restricted in what it can do.

In contrast to user mode is kernel mode, which the operating system(or kernel) runs in. In this mode code that runs can do what it likes, including privileged operations such as issuing I/O requests and executing

To users run restricted operations, virtually all modern hardware provides the ability for user programs to perform a system call. To execute a system call, a program must execute a special trap instruction. This instruction simultaneously jumps into the kernel and raises the
privilege level to kernel mode; once in the kernel, the system can now perform whatever privileged operations are needed (if allowed), and thus do the required work for the calling process. When finished, the OS calls a special return-from-trap instruction, which, as you might expect, returns
into the calling user program while simultaneously reducing the privilege level back to user mode.

Before executing the trap, the processor will push the program counter, flags, and a few other registers onto a per-process kernel stack.

2. how trap know which code to run inside the OS
We shouldn't CPU to execute any program when received trap instruction, The kernel does so by setting up a trap table at boot time. When the machine boots up, it does so in privileged (kernel) mode, and thus is free to configure machine hardware as need be. One of the first things the OS thus does is to tell the hardware what code to run when certain exceptional events occur

![LDE](https://github.com/770120041/myblog/blob/master/images/2019-4/MemoryAndCode.png?raw=true)


# Concurrency

# Persitence