---
layout: post
title:  Python Graph
categories: Interview
---
## 133. Clone Graph
Using dict

```py
class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node: return node
        d = {}
        def visitGraph(node,d):
            if node in d: return d[node]
            d[node] = Node(node.val)
            for neighbor in node.neighbors:
                d[node].neighbors.append(visitGraph(neighbor,d))
            return d[node]
        
        return visitGraph(node,d)
```

## 310. Minimum Height Trees
1. need a matrix and a indegree array
2. topo sort until there are 1 or 2 numbers in the queue, those are the roots
https://leetcode.com/problems/minimum-height-trees/discuss/76052/Two-O(n)-solutions

拓朴排序TLE了
```py
class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if n == 1: return [0]
        mat = [[False for i in range(n)] for j in range(n)]
        indegree = [0]*n
        for edge in edges:
            indegree[edge[0]]+=1
            indegree[edge[1]]+=1
            mat[edge[0]][edge[1]] = mat[edge[1]][edge[0]] = True
        q = []
        for i in range(n):
            if indegree[i] == 1:
                q.append(i)
        cnt = n
        # if there are more than 2 nodes left. We try to pop numbers out
        while cnt > 2 :
            sz = len(q)
            cnt -= sz
            for i in range(sz):
                cur = q.pop(0)
                for j in range(n):
                    if mat[j][cur]:
                        indegree[j]-=1
                        if indegree[j] == 1:
                            q.append(j)
        return q
```

## 399. Evaluate Division
```
class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        d = {}
        for i in range(len(values)):
            if equations[i][0] not in d: d[equations[i][0]] = []
            if equations[i][1] not in d: d[equations[i][1]] = []
            d[equations[i][0]].append((equations[i][1],values[i]))
            d[equations[i][1]].append((equations[i][0],1/values[i]))
        def dfs(cur,target,val,visited):
            if cur not in d: return -1.0
            if cur == target: return val
            visited.add(cur)
            for neighbor in d[cur]:
                if neighbor[0] not in visited:
                    ret = dfs(neighbor[0],target,val*neighbor[1],visited) 
                    if ret != -1.0: return ret
            visited.remove(cur)
            return -1.0
        res = []
        for query in queries:
            res += [dfs(query[0],query[1],1.0,set())]
        return res
```s