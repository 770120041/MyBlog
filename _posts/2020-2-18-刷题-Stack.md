---
layout: post
title:  Python - Stack
categories: Interview
---
```py
class MinStack:
    def __init__(self):
        self.s = []
        self.min = 9999999999

    def push(self, x: int) -> None:
        if x <= self.min:
            self.s.append(self.min)
            self.min = x
        self.s.append(x)
        # print(self.s)

    def pop(self) -> None:
        ret = self.s.pop()
        if ret == self.min:
            self.min = self.s.pop()
        return ret

    def top(self) -> int:
        return self.s[-1]

    def getMin(self) -> int:
        return self.min


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(x)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
```

## 232. Implement Queue using Stacks
```py
class MyQueue:
    def __init__(self):
        self.s1 = []
        self.s2 = []
        
    # pop the elment to another stack, so the head will be in top of stack.
    def push(self, x: int) -> None:
        self.s2.append(x)
        
    def pop(self) -> int:        
        self.peek()
        return self.s1.pop()    
        return s1.pop()
        
    def peek(self) -> int:
        if not self.s1:
            while self.s2:
                self.s1.append(self.s2.pop())
        return self.s1[-1]
        
    def empty(self) -> bool:
        return len(self.s1)+len(self.s2) == 0

# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()
```

## 225. Implement Stack using Queues

```cpp
class MyStack {
public:
    queue<int> q1,q2;
    /** Initialize your data structure here. */
    MyStack() {
        
    }
    
    /** Push element x onto stack. */
    void push(int x) {
        q2.push(x);
        while(!q1.empty()){
            q2.push(q1.front()); q1.pop();
        }
        q1 = q2;
        q2 = queue<int>();  
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int ret = q1.front(); q1.pop();
        return ret;
    }
    
    /** Get the top element. */
    int top() {
        return q1.front();
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return q1.empty();
    }
};
```

```py
class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.q1 = []
        self.q2 = []

    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.q1.append(x)

    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        for i in range(len(self.q1) - 1):
            self.q2.append(self.q1.pop(0))
        res = self.q1.pop(0)
        self.q1 = self.q2
        self.q2 = []
        return res
        

    def top(self) -> int:
        """
        Get the top element.
        """
        return self.q1[-1]
        

    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return len(self.q1) == 0
        
```

## 150. Evaluate Reverse Polish Notation
```py
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        s = []
        for token in tokens:
            if ("0"<=token[0]<="9") or (token[0] == "-" and len(token) != 1):
                s.append(int(token))
            else:
                num2 = s.pop()
                num1 = s.pop()
                if token == "+": s.append(num1+num2)  
                elif token == "-": s.append(num1-num2)
                elif token == "*": s.append(num1*num2)
                elif token == "/": 
                    if num1*num2 < 0:
                        s.append(-(abs(num1)//abs(num2)))
                    else:
                        s.append(num1//num2)
        return s[-1]
```

## 71. Simplify Path
```py
class Solution:
    def simplifyPath(self, path: str) -> str:
        tokens = path.split("/")
        s = []
        for token in tokens:
            if not token or token == ".": continue
            elif token == "..":
                if s: s.pop()
            else:
                s.append(token)
        return "/"+"/".join(s)
```

## 388. Longest Absolute File Path
```py
class Solution:
    def lengthLongestPath(self, input):
        maxlen = 0
        pathlen = {0: 0}
        for line in input.splitlines():
            name = line.lstrip('\t')
            # \t的个数就是depth
            depth = len(line) - len(name)
            if '.' in name:
            # 文件夹的深度加文件的长度
                maxlen = max(maxlen, pathlen[depth] + len(name))
            else:
            # 设置文件夹的深度
                pathlen[depth + 1] = pathlen[depth] + len(name) + 1
        return maxlen
```