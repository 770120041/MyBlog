---
layout: post
title:  Python(2)
categories: Interview
---
## 10. Regular Expression Matching
#### Brute Force(TLE)

1. 若p为空，则s必须为空 `if not p: return not s`
2. 若s为空，那么p必须是.*或者x*,但可能有多个(x*)组成，所以可以通过从后往前判断
3. 如果s不为空，并且p[1]='*',如果p[1]等于*，那么可以是匹配0个，或者匹配很多个(需要判断第一个匹配)
4. 如果p[1] != '*',正常判断

```python
class Solution(object):
    def isMatch(self, s, p):
        # p emtpy
        if not p:
            return not s
        # s empty
        if not s:
            if len(p) > 1 and p[1] == '*':
                return self.isMatch(s,p[2:])
            else:
                return False
        # has *, judge if s is empty of first match
        if len(p)>1 and p[1] == '*':
            return ((p[0]=='.' or(p[0]==s[0])) and (self.isMatch(s[1:],p) or self.isMatch(s[1:],p[2:]))
                   ) or self.isMatch(s,p[2:])
        # no *
        if (p[0]=='.' or(p[0]==s[0])):
            return self.isMatch(s[1:],p[1:])
        return False
```

#### cache
What to cache? if substring s and substring p matches. Don't check same string twice
```
class Solution(object):
    cache = {}
    def isMatch(self, s, p):
        # p emtpy
        if not p:
            return not s
        if (s,p) in self.cache:
            return self.cache[(s,p)]
        # if s empty, only when p is multiple 'x*' will be match
        if not s:
            if len(p) > 1 and p[1] == '*' and self.isMatch(s,p[2:]):
                self.cache[(s,p)] = True;
                return True;
            else:
                return False
        # p[1] = '*', then x* match 0,1 or many,(for matching 0, don't need to match first character)
        if len(p)>1 and p[1] == '*':
            if self.isMatch(s,p[2:]) or ((p[0]=='.' or(p[0]==s[0])) and (self.isMatch(s[1:],p) or self.isMatch(s[1:],p[2:]))):
                self.cache[(s,p)] = True;
                return True;
            
        # p[1] != '*', just judge if first match
        if (p[0]=='.' or(p[0]==s[0])) and  self.isMatch(s[1:],p[1:]):
            self.cache[(s,p)] = True
            return True
        self.cache[(s,p)] = False
        return False
```

#### dp
[video](https://www.youtube.com/watch?v=l3hda49XcDE&feature=youtu.be)
```
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        s,p = ' '+s,' '+p
        s_len,p_len = len(s),len(p)
        dp = [[False] * p_len for _ in range(s_len)]
        dp[0][0] = True
        # handles cases when s is ""
        for j in range(1,p_len):
            if p[j] == '*':
                dp[0][j] = dp[0][j-2]
        for i in range(1,s_len):
            for j in range(1,p_len):
                if (p[j] in {s[i],'.'}):
                    dp[i][j] = dp[i-1][j-1] 
                elif p[j] == '*':
                    dp[i][j] = (dp[i][j-2]) or ((p[j-1] in {s[i],'.'}) and dp[i-1][j])
        return dp[-1][-1]
```

## 11. Container With Most Water
```
class Solution:
    def maxArea(self, height: List[int]) -> int:
        result = 0
        l,r = 0, len(height)-1
        while l < r:
            result = max(result,(r-l)*min(height[l],height[r]))
            if height[l] < height[r]:
                l += 1
            else:
                r -= 1
        return result
```

## 12. Integer to Roman
```
class Solution:
    def intToRoman(self, num: int) -> str:
        rom_num = ("M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I")
        int_num = (1000,900,500,400,100,90,50,40,10,9,5,4,1)
        result = ""
        for i,n in enumerate(int_num):
            while num >= n:
                result += rom_num[i]
                num -= n
        return result
```

## 13. Roman to Integer
```
class Solution:
    def romanToInt(self, s: str) -> int:
        d = {
            "M":1000,
            "CM":900,
            "D":500,
            "CD":400,
            "C":100,
            "XC":90,
            "L":50,
            "XL":40,
            "X":10,
            "IX":9,
            "V":5,
            "IV":4,
            "I":1
        }
        idx = 0
        res = 0
        while idx < len(s):
            if idx < len(s)-1 and s[idx:idx+2] in d:
                # print(d[s[idx:idx+2]])
                res += d[s[idx:idx+2]]
                idx += 2
            else:
                res += d[s[idx]]
                idx += 1
        return res
```

