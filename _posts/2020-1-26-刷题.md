---
layout: post
title:  Python(2)
categories: Interview
---
## 10. Regular Expression Matching
#### Brute Force(TLE)

1. 若p为空，则s必须为空 `if not p: return not s`
2. 若s为空，那么p必须是.*或者x*,但可能有多个(x*)组成，所以可以通过从后往前判断
3. 如果s不为空，并且p[1]='*',如果p[1]等于*，那么可以是匹配0个，或者匹配很多个(需要判断第一个匹配)
4. 如果p[1] != '*',正常判断

```python
class Solution(object):
    def isMatch(self, s, p):
        # p emtpy
        if not p:
            return not s
        # s empty
        if not s:
            if len(p) > 1 and p[1] == '*':
                return self.isMatch(s,p[2:])
            else:
                return False
        # has *, judge if s is empty of first match
        if len(p)>1 and p[1] == '*':
            return ((p[0]=='.' or(p[0]==s[0])) and (self.isMatch(s[1:],p) or self.isMatch(s[1:],p[2:]))
                   ) or self.isMatch(s,p[2:])
        # no *
        if (p[0]=='.' or(p[0]==s[0])):
            return self.isMatch(s[1:],p[1:])
        return False
```

#### cache
What to cache? if substring s and substring p matches. Don't check same string twice
```
class Solution(object):
    cache = {}
    def isMatch(self, s, p):
        # p emtpy
        if not p:
            return not s
        if (s,p) in self.cache:
            return self.cache[(s,p)]
        # if s empty, only when p is multiple 'x*' will be match
        if not s:
            if len(p) > 1 and p[1] == '*' and self.isMatch(s,p[2:]):
                self.cache[(s,p)] = True;
                return True;
            else:
                return False
        # p[1] = '*', then x* match 0,1 or many,(for matching 0, don't need to match first character)
        if len(p)>1 and p[1] == '*':
            if self.isMatch(s,p[2:]) or ((p[0]=='.' or(p[0]==s[0])) and (self.isMatch(s[1:],p) or self.isMatch(s[1:],p[2:]))):
                self.cache[(s,p)] = True;
                return True;
            
        # p[1] != '*', just judge if first match
        if (p[0]=='.' or(p[0]==s[0])) and  self.isMatch(s[1:],p[1:]):
            self.cache[(s,p)] = True
            return True
        self.cache[(s,p)] = False
        return False
```