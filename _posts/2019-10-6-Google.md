---
layout: post
title:  Google
categories: Interview
---
## Lc 754 Reach a Number 
Trick1: target and -target cost same amount of steps. 如果是负的，那么所有步取反就可以获得正的结果，所以可以只考虑累加为正的情况
Trick2: 超过目标值的数目d若为偶数，则d/2步取反
Trick3: 若d为奇数，若下一步N+1为奇数，那么加上奇数就变成偶数了，否则走N+1和N+2两步，加上一个偶数一个奇数，结果变成偶数

我们先对 target 取绝对值，因为正负不影响最小步数。然后我们求出第n步，使得从1累加到n刚好大于等于 target，那么利用求和公式就有：

target = n * (n + 1) / 2

变成一元二次方程方程即为：

n^2 + n - 2*target = 0

用初中的一元二次方程的求和公式，就有：

n = (-1 + sqrt(1 + 8*target)) / 2

当然算出来可能不是整数，所以要取整，这里使用 ceil 来取整。如果此时 sum 和 target 正好相等，perfect！直接返回n，否则就是计算差值，如果差值时偶数，那么也直接返回n，如果是奇数，判断此时n的奇偶，如果n是奇数，则返回 n+2，若n是偶数，返回 n+1，参见代码如下：


#### 模拟
````
class Solution {
public:
    int reachNumber(int target) {
        target = abs(target);
        int res = 0; 
        int sum = 0;
        while(sum < target or (sum-target)%2 == 1){
            ++res;
            sum+= res;
        }
        return res;
    }
};
````

<hr>

## 388. Longest Absolute File Path
文件路径题目：用stack来追踪当前的阶层


Trick: for each lines, push it to the stack
一个`\t`代表一个缩进，根据缩进的数目判断

```
class Solution {
public:
    int lengthLongestPath(string input) {
        int result = 0;
        vector<string> lines;
        int left = 0;
        for(int i=0;i<input.size();i++){
            if(i == input.size()-1) lines.push_back(input.substr(left));
            else if(input[i] == '\n'){
                lines.push_back(input.substr(left,i-left));
                left = i+1;
            } 
        }
        //the first is the number of level, the second is the total length
        stack<pair<int,int>> s;
        // cout<<"lines:"<<lines.size()<<endl;
        for(int i=0;i<lines.size();i++){
            int level = lines[i].find_last_of('\t')+1;
            // cout<<level<<endl;
            while(!s.empty() and s.top().first >= level ) s.pop();
            int curSize = s.empty()? 0 : s.top().second;
            s.push(make_pair(level,curSize+lines[i].size() - level));
            // cout<<s.top().second<<" "<<s.top().first<<endl;
            if(lines[i].find(".")!=string::npos)
                result = max(result,s.top().second+s.top().first);
        }
        return result;
    }
};
```

<hr>

## 861. K Empty Slots(Lintcode)
[blog](https://www.cnblogs.com/grandyang/p/8415880.html)

```
class Solution {
public:
    int kEmptySlots(vector<int>& flowers, int k) {
        int res = INT_MAX, left = 0, right = k + 1, n = flowers.size();
        vector<int> days(n, 0);
        for (int i = 0; i < n; ++i) days[flowers[i] - 1] = i + 1;
        for (int i = 0; right < n; ++i) {
            if (days[i] < days[left] || days[i] <= days[right]) {
                if (i == right) res = min(res, max(days[left], days[right]));
                left = i; 
                right = k + 1 + i;
            }
        }
        return (res == INT_MAX) ? -1 : res;
    }
};
```

#### TreeSet(Java)
```
public class Solution {
    /**
     * @param flowers: the place where the flower will open in that day
     * @param k:  an integer
     * @return: in which day meet the requirements
     */
    public int kEmptySlots(int[] flowers, int k) {
        int n = flowers.length;
        if(n == 0 || n == 1) return 1;
        //sort means the position of blooming flowers
        TreeSet<Integer> sort = new TreeSet<>();
        for(int i=0;i<n;i++){
            sort.add(flowers[i]);
            Integer minPos = sort.lower(flowers[i]);
            Integer maxPos = sort.higher(flowers[i]);
            if(minPos != null && flowers[i] - minPos == k+1) return i+1;
            if(maxPos != null && maxPos - flowers[i] == k+1) return i+1;
        }
        return -1;
    }
}
```

<hr>

## 681 Next closest time
reusing digit?

#### 